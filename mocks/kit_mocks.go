// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	"github.com/mikhailbolshakov/kit"
	mock "github.com/stretchr/testify/mock"
)

// NewKitAppErrBuilder creates a new instance of KitAppErrBuilder. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKitAppErrBuilder(t interface {
	mock.TestingT
	Cleanup(func())
}) *KitAppErrBuilder {
	mock := &KitAppErrBuilder{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KitAppErrBuilder is an autogenerated mock type for the AppErrBuilder type
type KitAppErrBuilder struct {
	mock.Mock
}

type KitAppErrBuilder_Expecter struct {
	mock *mock.Mock
}

func (_m *KitAppErrBuilder) EXPECT() *KitAppErrBuilder_Expecter {
	return &KitAppErrBuilder_Expecter{mock: &_m.Mock}
}

// Business provides a mock function for the type KitAppErrBuilder
func (_mock *KitAppErrBuilder) Business() kit.AppErrBuilder {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Business")
	}

	var r0 kit.AppErrBuilder
	if returnFunc, ok := ret.Get(0).(func() kit.AppErrBuilder); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.AppErrBuilder)
		}
	}
	return r0
}

// KitAppErrBuilder_Business_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Business'
type KitAppErrBuilder_Business_Call struct {
	*mock.Call
}

// Business is a helper method to define mock.On call
func (_e *KitAppErrBuilder_Expecter) Business() *KitAppErrBuilder_Business_Call {
	return &KitAppErrBuilder_Business_Call{Call: _e.mock.On("Business")}
}

func (_c *KitAppErrBuilder_Business_Call) Run(run func()) *KitAppErrBuilder_Business_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KitAppErrBuilder_Business_Call) Return(appErrBuilder kit.AppErrBuilder) *KitAppErrBuilder_Business_Call {
	_c.Call.Return(appErrBuilder)
	return _c
}

func (_c *KitAppErrBuilder_Business_Call) RunAndReturn(run func() kit.AppErrBuilder) *KitAppErrBuilder_Business_Call {
	_c.Call.Return(run)
	return _c
}

// C provides a mock function for the type KitAppErrBuilder
func (_mock *KitAppErrBuilder) C(ctx context.Context) kit.AppErrBuilder {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for C")
	}

	var r0 kit.AppErrBuilder
	if returnFunc, ok := ret.Get(0).(func(context.Context) kit.AppErrBuilder); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.AppErrBuilder)
		}
	}
	return r0
}

// KitAppErrBuilder_C_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'C'
type KitAppErrBuilder_C_Call struct {
	*mock.Call
}

// C is a helper method to define mock.On call
//   - ctx
func (_e *KitAppErrBuilder_Expecter) C(ctx interface{}) *KitAppErrBuilder_C_Call {
	return &KitAppErrBuilder_C_Call{Call: _e.mock.On("C", ctx)}
}

func (_c *KitAppErrBuilder_C_Call) Run(run func(ctx context.Context)) *KitAppErrBuilder_C_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *KitAppErrBuilder_C_Call) Return(appErrBuilder kit.AppErrBuilder) *KitAppErrBuilder_C_Call {
	_c.Call.Return(appErrBuilder)
	return _c
}

func (_c *KitAppErrBuilder_C_Call) RunAndReturn(run func(ctx context.Context) kit.AppErrBuilder) *KitAppErrBuilder_C_Call {
	_c.Call.Return(run)
	return _c
}

// Err provides a mock function for the type KitAppErrBuilder
func (_mock *KitAppErrBuilder) Err() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Err")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KitAppErrBuilder_Err_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Err'
type KitAppErrBuilder_Err_Call struct {
	*mock.Call
}

// Err is a helper method to define mock.On call
func (_e *KitAppErrBuilder_Expecter) Err() *KitAppErrBuilder_Err_Call {
	return &KitAppErrBuilder_Err_Call{Call: _e.mock.On("Err")}
}

func (_c *KitAppErrBuilder_Err_Call) Run(run func()) *KitAppErrBuilder_Err_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KitAppErrBuilder_Err_Call) Return(err error) *KitAppErrBuilder_Err_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *KitAppErrBuilder_Err_Call) RunAndReturn(run func() error) *KitAppErrBuilder_Err_Call {
	_c.Call.Return(run)
	return _c
}

// F provides a mock function for the type KitAppErrBuilder
func (_mock *KitAppErrBuilder) F(fields kit.KV) kit.AppErrBuilder {
	ret := _mock.Called(fields)

	if len(ret) == 0 {
		panic("no return value specified for F")
	}

	var r0 kit.AppErrBuilder
	if returnFunc, ok := ret.Get(0).(func(kit.KV) kit.AppErrBuilder); ok {
		r0 = returnFunc(fields)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.AppErrBuilder)
		}
	}
	return r0
}

// KitAppErrBuilder_F_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'F'
type KitAppErrBuilder_F_Call struct {
	*mock.Call
}

// F is a helper method to define mock.On call
//   - fields
func (_e *KitAppErrBuilder_Expecter) F(fields interface{}) *KitAppErrBuilder_F_Call {
	return &KitAppErrBuilder_F_Call{Call: _e.mock.On("F", fields)}
}

func (_c *KitAppErrBuilder_F_Call) Run(run func(fields kit.KV)) *KitAppErrBuilder_F_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(kit.KV))
	})
	return _c
}

func (_c *KitAppErrBuilder_F_Call) Return(appErrBuilder kit.AppErrBuilder) *KitAppErrBuilder_F_Call {
	_c.Call.Return(appErrBuilder)
	return _c
}

func (_c *KitAppErrBuilder_F_Call) RunAndReturn(run func(fields kit.KV) kit.AppErrBuilder) *KitAppErrBuilder_F_Call {
	_c.Call.Return(run)
	return _c
}

// GrpcSt provides a mock function for the type KitAppErrBuilder
func (_mock *KitAppErrBuilder) GrpcSt(status uint32) kit.AppErrBuilder {
	ret := _mock.Called(status)

	if len(ret) == 0 {
		panic("no return value specified for GrpcSt")
	}

	var r0 kit.AppErrBuilder
	if returnFunc, ok := ret.Get(0).(func(uint32) kit.AppErrBuilder); ok {
		r0 = returnFunc(status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.AppErrBuilder)
		}
	}
	return r0
}

// KitAppErrBuilder_GrpcSt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GrpcSt'
type KitAppErrBuilder_GrpcSt_Call struct {
	*mock.Call
}

// GrpcSt is a helper method to define mock.On call
//   - status
func (_e *KitAppErrBuilder_Expecter) GrpcSt(status interface{}) *KitAppErrBuilder_GrpcSt_Call {
	return &KitAppErrBuilder_GrpcSt_Call{Call: _e.mock.On("GrpcSt", status)}
}

func (_c *KitAppErrBuilder_GrpcSt_Call) Run(run func(status uint32)) *KitAppErrBuilder_GrpcSt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint32))
	})
	return _c
}

func (_c *KitAppErrBuilder_GrpcSt_Call) Return(appErrBuilder kit.AppErrBuilder) *KitAppErrBuilder_GrpcSt_Call {
	_c.Call.Return(appErrBuilder)
	return _c
}

func (_c *KitAppErrBuilder_GrpcSt_Call) RunAndReturn(run func(status uint32) kit.AppErrBuilder) *KitAppErrBuilder_GrpcSt_Call {
	_c.Call.Return(run)
	return _c
}

// HttpSt provides a mock function for the type KitAppErrBuilder
func (_mock *KitAppErrBuilder) HttpSt(status uint32) kit.AppErrBuilder {
	ret := _mock.Called(status)

	if len(ret) == 0 {
		panic("no return value specified for HttpSt")
	}

	var r0 kit.AppErrBuilder
	if returnFunc, ok := ret.Get(0).(func(uint32) kit.AppErrBuilder); ok {
		r0 = returnFunc(status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.AppErrBuilder)
		}
	}
	return r0
}

// KitAppErrBuilder_HttpSt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HttpSt'
type KitAppErrBuilder_HttpSt_Call struct {
	*mock.Call
}

// HttpSt is a helper method to define mock.On call
//   - status
func (_e *KitAppErrBuilder_Expecter) HttpSt(status interface{}) *KitAppErrBuilder_HttpSt_Call {
	return &KitAppErrBuilder_HttpSt_Call{Call: _e.mock.On("HttpSt", status)}
}

func (_c *KitAppErrBuilder_HttpSt_Call) Run(run func(status uint32)) *KitAppErrBuilder_HttpSt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint32))
	})
	return _c
}

func (_c *KitAppErrBuilder_HttpSt_Call) Return(appErrBuilder kit.AppErrBuilder) *KitAppErrBuilder_HttpSt_Call {
	_c.Call.Return(appErrBuilder)
	return _c
}

func (_c *KitAppErrBuilder_HttpSt_Call) RunAndReturn(run func(status uint32) kit.AppErrBuilder) *KitAppErrBuilder_HttpSt_Call {
	_c.Call.Return(run)
	return _c
}

// Panic provides a mock function for the type KitAppErrBuilder
func (_mock *KitAppErrBuilder) Panic() kit.AppErrBuilder {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Panic")
	}

	var r0 kit.AppErrBuilder
	if returnFunc, ok := ret.Get(0).(func() kit.AppErrBuilder); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.AppErrBuilder)
		}
	}
	return r0
}

// KitAppErrBuilder_Panic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Panic'
type KitAppErrBuilder_Panic_Call struct {
	*mock.Call
}

// Panic is a helper method to define mock.On call
func (_e *KitAppErrBuilder_Expecter) Panic() *KitAppErrBuilder_Panic_Call {
	return &KitAppErrBuilder_Panic_Call{Call: _e.mock.On("Panic")}
}

func (_c *KitAppErrBuilder_Panic_Call) Run(run func()) *KitAppErrBuilder_Panic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KitAppErrBuilder_Panic_Call) Return(appErrBuilder kit.AppErrBuilder) *KitAppErrBuilder_Panic_Call {
	_c.Call.Return(appErrBuilder)
	return _c
}

func (_c *KitAppErrBuilder_Panic_Call) RunAndReturn(run func() kit.AppErrBuilder) *KitAppErrBuilder_Panic_Call {
	_c.Call.Return(run)
	return _c
}

// System provides a mock function for the type KitAppErrBuilder
func (_mock *KitAppErrBuilder) System() kit.AppErrBuilder {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for System")
	}

	var r0 kit.AppErrBuilder
	if returnFunc, ok := ret.Get(0).(func() kit.AppErrBuilder); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.AppErrBuilder)
		}
	}
	return r0
}

// KitAppErrBuilder_System_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'System'
type KitAppErrBuilder_System_Call struct {
	*mock.Call
}

// System is a helper method to define mock.On call
func (_e *KitAppErrBuilder_Expecter) System() *KitAppErrBuilder_System_Call {
	return &KitAppErrBuilder_System_Call{Call: _e.mock.On("System")}
}

func (_c *KitAppErrBuilder_System_Call) Run(run func()) *KitAppErrBuilder_System_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KitAppErrBuilder_System_Call) Return(appErrBuilder kit.AppErrBuilder) *KitAppErrBuilder_System_Call {
	_c.Call.Return(appErrBuilder)
	return _c
}

func (_c *KitAppErrBuilder_System_Call) RunAndReturn(run func() kit.AppErrBuilder) *KitAppErrBuilder_System_Call {
	_c.Call.Return(run)
	return _c
}

// Type provides a mock function for the type KitAppErrBuilder
func (_mock *KitAppErrBuilder) Type(t string) kit.AppErrBuilder {
	ret := _mock.Called(t)

	if len(ret) == 0 {
		panic("no return value specified for Type")
	}

	var r0 kit.AppErrBuilder
	if returnFunc, ok := ret.Get(0).(func(string) kit.AppErrBuilder); ok {
		r0 = returnFunc(t)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.AppErrBuilder)
		}
	}
	return r0
}

// KitAppErrBuilder_Type_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Type'
type KitAppErrBuilder_Type_Call struct {
	*mock.Call
}

// Type is a helper method to define mock.On call
//   - t
func (_e *KitAppErrBuilder_Expecter) Type(t interface{}) *KitAppErrBuilder_Type_Call {
	return &KitAppErrBuilder_Type_Call{Call: _e.mock.On("Type", t)}
}

func (_c *KitAppErrBuilder_Type_Call) Run(run func(t string)) *KitAppErrBuilder_Type_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *KitAppErrBuilder_Type_Call) Return(appErrBuilder kit.AppErrBuilder) *KitAppErrBuilder_Type_Call {
	_c.Call.Return(appErrBuilder)
	return _c
}

func (_c *KitAppErrBuilder_Type_Call) RunAndReturn(run func(t string) kit.AppErrBuilder) *KitAppErrBuilder_Type_Call {
	_c.Call.Return(run)
	return _c
}

// Wrap provides a mock function for the type KitAppErrBuilder
func (_mock *KitAppErrBuilder) Wrap(cause error) kit.AppErrBuilder {
	ret := _mock.Called(cause)

	if len(ret) == 0 {
		panic("no return value specified for Wrap")
	}

	var r0 kit.AppErrBuilder
	if returnFunc, ok := ret.Get(0).(func(error) kit.AppErrBuilder); ok {
		r0 = returnFunc(cause)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.AppErrBuilder)
		}
	}
	return r0
}

// KitAppErrBuilder_Wrap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Wrap'
type KitAppErrBuilder_Wrap_Call struct {
	*mock.Call
}

// Wrap is a helper method to define mock.On call
//   - cause
func (_e *KitAppErrBuilder_Expecter) Wrap(cause interface{}) *KitAppErrBuilder_Wrap_Call {
	return &KitAppErrBuilder_Wrap_Call{Call: _e.mock.On("Wrap", cause)}
}

func (_c *KitAppErrBuilder_Wrap_Call) Run(run func(cause error)) *KitAppErrBuilder_Wrap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(error))
	})
	return _c
}

func (_c *KitAppErrBuilder_Wrap_Call) Return(appErrBuilder kit.AppErrBuilder) *KitAppErrBuilder_Wrap_Call {
	_c.Call.Return(appErrBuilder)
	return _c
}

func (_c *KitAppErrBuilder_Wrap_Call) RunAndReturn(run func(cause error) kit.AppErrBuilder) *KitAppErrBuilder_Wrap_Call {
	_c.Call.Return(run)
	return _c
}

// NewKitAdapter creates a new instance of KitAdapter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKitAdapter[T any](t interface {
	mock.TestingT
	Cleanup(func())
}) *KitAdapter[T] {
	mock := &KitAdapter[T]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KitAdapter is an autogenerated mock type for the Adapter type
type KitAdapter[T any] struct {
	mock.Mock
}

type KitAdapter_Expecter[T any] struct {
	mock *mock.Mock
}

func (_m *KitAdapter[T]) EXPECT() *KitAdapter_Expecter[T] {
	return &KitAdapter_Expecter[T]{mock: &_m.Mock}
}

// Close provides a mock function for the type KitAdapter
func (_mock *KitAdapter[T]) Close(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KitAdapter_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type KitAdapter_Close_Call[T any] struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
//   - ctx
func (_e *KitAdapter_Expecter[T]) Close(ctx interface{}) *KitAdapter_Close_Call[T] {
	return &KitAdapter_Close_Call[T]{Call: _e.mock.On("Close", ctx)}
}

func (_c *KitAdapter_Close_Call[T]) Run(run func(ctx context.Context)) *KitAdapter_Close_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *KitAdapter_Close_Call[T]) Return(err error) *KitAdapter_Close_Call[T] {
	_c.Call.Return(err)
	return _c
}

func (_c *KitAdapter_Close_Call[T]) RunAndReturn(run func(ctx context.Context) error) *KitAdapter_Close_Call[T] {
	_c.Call.Return(run)
	return _c
}

// Init provides a mock function for the type KitAdapter
func (_mock *KitAdapter[T]) Init(ctx context.Context, cfg *T) error {
	ret := _mock.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for Init")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *T) error); ok {
		r0 = returnFunc(ctx, cfg)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KitAdapter_Init_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Init'
type KitAdapter_Init_Call[T any] struct {
	*mock.Call
}

// Init is a helper method to define mock.On call
//   - ctx
//   - cfg
func (_e *KitAdapter_Expecter[T]) Init(ctx interface{}, cfg interface{}) *KitAdapter_Init_Call[T] {
	return &KitAdapter_Init_Call[T]{Call: _e.mock.On("Init", ctx, cfg)}
}

func (_c *KitAdapter_Init_Call[T]) Run(run func(ctx context.Context, cfg *T)) *KitAdapter_Init_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*T))
	})
	return _c
}

func (_c *KitAdapter_Init_Call[T]) Return(err error) *KitAdapter_Init_Call[T] {
	_c.Call.Return(err)
	return _c
}

func (_c *KitAdapter_Init_Call[T]) RunAndReturn(run func(ctx context.Context, cfg *T) error) *KitAdapter_Init_Call[T] {
	_c.Call.Return(run)
	return _c
}

// NewKitAdapterListener creates a new instance of KitAdapterListener. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKitAdapterListener[T any](t interface {
	mock.TestingT
	Cleanup(func())
}) *KitAdapterListener[T] {
	mock := &KitAdapterListener[T]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KitAdapterListener is an autogenerated mock type for the AdapterListener type
type KitAdapterListener[T any] struct {
	mock.Mock
}

type KitAdapterListener_Expecter[T any] struct {
	mock *mock.Mock
}

func (_m *KitAdapterListener[T]) EXPECT() *KitAdapterListener_Expecter[T] {
	return &KitAdapterListener_Expecter[T]{mock: &_m.Mock}
}

// Close provides a mock function for the type KitAdapterListener
func (_mock *KitAdapterListener[T]) Close(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KitAdapterListener_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type KitAdapterListener_Close_Call[T any] struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
//   - ctx
func (_e *KitAdapterListener_Expecter[T]) Close(ctx interface{}) *KitAdapterListener_Close_Call[T] {
	return &KitAdapterListener_Close_Call[T]{Call: _e.mock.On("Close", ctx)}
}

func (_c *KitAdapterListener_Close_Call[T]) Run(run func(ctx context.Context)) *KitAdapterListener_Close_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *KitAdapterListener_Close_Call[T]) Return(err error) *KitAdapterListener_Close_Call[T] {
	_c.Call.Return(err)
	return _c
}

func (_c *KitAdapterListener_Close_Call[T]) RunAndReturn(run func(ctx context.Context) error) *KitAdapterListener_Close_Call[T] {
	_c.Call.Return(run)
	return _c
}

// Init provides a mock function for the type KitAdapterListener
func (_mock *KitAdapterListener[T]) Init(ctx context.Context, cfg *T) error {
	ret := _mock.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for Init")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *T) error); ok {
		r0 = returnFunc(ctx, cfg)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KitAdapterListener_Init_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Init'
type KitAdapterListener_Init_Call[T any] struct {
	*mock.Call
}

// Init is a helper method to define mock.On call
//   - ctx
//   - cfg
func (_e *KitAdapterListener_Expecter[T]) Init(ctx interface{}, cfg interface{}) *KitAdapterListener_Init_Call[T] {
	return &KitAdapterListener_Init_Call[T]{Call: _e.mock.On("Init", ctx, cfg)}
}

func (_c *KitAdapterListener_Init_Call[T]) Run(run func(ctx context.Context, cfg *T)) *KitAdapterListener_Init_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*T))
	})
	return _c
}

func (_c *KitAdapterListener_Init_Call[T]) Return(err error) *KitAdapterListener_Init_Call[T] {
	_c.Call.Return(err)
	return _c
}

func (_c *KitAdapterListener_Init_Call[T]) RunAndReturn(run func(ctx context.Context, cfg *T) error) *KitAdapterListener_Init_Call[T] {
	_c.Call.Return(run)
	return _c
}

// ListenAsync provides a mock function for the type KitAdapterListener
func (_mock *KitAdapterListener[T]) ListenAsync(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListenAsync")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KitAdapterListener_ListenAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListenAsync'
type KitAdapterListener_ListenAsync_Call[T any] struct {
	*mock.Call
}

// ListenAsync is a helper method to define mock.On call
//   - ctx
func (_e *KitAdapterListener_Expecter[T]) ListenAsync(ctx interface{}) *KitAdapterListener_ListenAsync_Call[T] {
	return &KitAdapterListener_ListenAsync_Call[T]{Call: _e.mock.On("ListenAsync", ctx)}
}

func (_c *KitAdapterListener_ListenAsync_Call[T]) Run(run func(ctx context.Context)) *KitAdapterListener_ListenAsync_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *KitAdapterListener_ListenAsync_Call[T]) Return(err error) *KitAdapterListener_ListenAsync_Call[T] {
	_c.Call.Return(err)
	return _c
}

func (_c *KitAdapterListener_ListenAsync_Call[T]) RunAndReturn(run func(ctx context.Context) error) *KitAdapterListener_ListenAsync_Call[T] {
	_c.Call.Return(run)
	return _c
}

// NewKitSearchable creates a new instance of KitSearchable. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKitSearchable[TItem any, Rq any](t interface {
	mock.TestingT
	Cleanup(func())
}) *KitSearchable[TItem, Rq] {
	mock := &KitSearchable[TItem, Rq]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KitSearchable is an autogenerated mock type for the Searchable type
type KitSearchable[TItem any, Rq any] struct {
	mock.Mock
}

type KitSearchable_Expecter[TItem any, Rq any] struct {
	mock *mock.Mock
}

func (_m *KitSearchable[TItem, Rq]) EXPECT() *KitSearchable_Expecter[TItem, Rq] {
	return &KitSearchable_Expecter[TItem, Rq]{mock: &_m.Mock}
}

// Search provides a mock function for the type KitSearchable
func (_mock *KitSearchable[TItem, Rq]) Search(ctx context.Context, rq kit.PagingRequestG[Rq]) (kit.PagingResponseG[TItem], error) {
	ret := _mock.Called(ctx, rq)

	if len(ret) == 0 {
		panic("no return value specified for Search")
	}

	var r0 kit.PagingResponseG[TItem]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, kit.PagingRequestG[Rq]) (kit.PagingResponseG[TItem], error)); ok {
		return returnFunc(ctx, rq)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, kit.PagingRequestG[Rq]) kit.PagingResponseG[TItem]); ok {
		r0 = returnFunc(ctx, rq)
	} else {
		r0 = ret.Get(0).(kit.PagingResponseG[TItem])
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, kit.PagingRequestG[Rq]) error); ok {
		r1 = returnFunc(ctx, rq)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// KitSearchable_Search_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Search'
type KitSearchable_Search_Call[TItem any, Rq any] struct {
	*mock.Call
}

// Search is a helper method to define mock.On call
//   - ctx
//   - rq
func (_e *KitSearchable_Expecter[TItem, Rq]) Search(ctx interface{}, rq interface{}) *KitSearchable_Search_Call[TItem, Rq] {
	return &KitSearchable_Search_Call[TItem, Rq]{Call: _e.mock.On("Search", ctx, rq)}
}

func (_c *KitSearchable_Search_Call[TItem, Rq]) Run(run func(ctx context.Context, rq kit.PagingRequestG[Rq])) *KitSearchable_Search_Call[TItem, Rq] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(kit.PagingRequestG[Rq]))
	})
	return _c
}

func (_c *KitSearchable_Search_Call[TItem, Rq]) Return(pagingResponseG kit.PagingResponseG[TItem], err error) *KitSearchable_Search_Call[TItem, Rq] {
	_c.Call.Return(pagingResponseG, err)
	return _c
}

func (_c *KitSearchable_Search_Call[TItem, Rq]) RunAndReturn(run func(ctx context.Context, rq kit.PagingRequestG[Rq]) (kit.PagingResponseG[TItem], error)) *KitSearchable_Search_Call[TItem, Rq] {
	_c.Call.Return(run)
	return _c
}

// NewKitDistributedLockStorage creates a new instance of KitDistributedLockStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKitDistributedLockStorage(t interface {
	mock.TestingT
	Cleanup(func())
}) *KitDistributedLockStorage {
	mock := &KitDistributedLockStorage{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KitDistributedLockStorage is an autogenerated mock type for the DistributedLockStorage type
type KitDistributedLockStorage struct {
	mock.Mock
}

type KitDistributedLockStorage_Expecter struct {
	mock *mock.Mock
}

func (_m *KitDistributedLockStorage) EXPECT() *KitDistributedLockStorage_Expecter {
	return &KitDistributedLockStorage_Expecter{mock: &_m.Mock}
}

// Lock provides a mock function for the type KitDistributedLockStorage
func (_mock *KitDistributedLockStorage) Lock(ctx context.Context, ref string, releaseId string) (bool, error) {
	ret := _mock.Called(ctx, ref, releaseId)

	if len(ret) == 0 {
		panic("no return value specified for Lock")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return returnFunc(ctx, ref, releaseId)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = returnFunc(ctx, ref, releaseId)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, ref, releaseId)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// KitDistributedLockStorage_Lock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Lock'
type KitDistributedLockStorage_Lock_Call struct {
	*mock.Call
}

// Lock is a helper method to define mock.On call
//   - ctx
//   - ref
//   - releaseId
func (_e *KitDistributedLockStorage_Expecter) Lock(ctx interface{}, ref interface{}, releaseId interface{}) *KitDistributedLockStorage_Lock_Call {
	return &KitDistributedLockStorage_Lock_Call{Call: _e.mock.On("Lock", ctx, ref, releaseId)}
}

func (_c *KitDistributedLockStorage_Lock_Call) Run(run func(ctx context.Context, ref string, releaseId string)) *KitDistributedLockStorage_Lock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *KitDistributedLockStorage_Lock_Call) Return(b bool, err error) *KitDistributedLockStorage_Lock_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *KitDistributedLockStorage_Lock_Call) RunAndReturn(run func(ctx context.Context, ref string, releaseId string) (bool, error)) *KitDistributedLockStorage_Lock_Call {
	_c.Call.Return(run)
	return _c
}

// UnLock provides a mock function for the type KitDistributedLockStorage
func (_mock *KitDistributedLockStorage) UnLock(ctx context.Context, ref string, releaseId string) error {
	ret := _mock.Called(ctx, ref, releaseId)

	if len(ret) == 0 {
		panic("no return value specified for UnLock")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, ref, releaseId)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KitDistributedLockStorage_UnLock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnLock'
type KitDistributedLockStorage_UnLock_Call struct {
	*mock.Call
}

// UnLock is a helper method to define mock.On call
//   - ctx
//   - ref
//   - releaseId
func (_e *KitDistributedLockStorage_Expecter) UnLock(ctx interface{}, ref interface{}, releaseId interface{}) *KitDistributedLockStorage_UnLock_Call {
	return &KitDistributedLockStorage_UnLock_Call{Call: _e.mock.On("UnLock", ctx, ref, releaseId)}
}

func (_c *KitDistributedLockStorage_UnLock_Call) Run(run func(ctx context.Context, ref string, releaseId string)) *KitDistributedLockStorage_UnLock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *KitDistributedLockStorage_UnLock_Call) Return(err error) *KitDistributedLockStorage_UnLock_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *KitDistributedLockStorage_UnLock_Call) RunAndReturn(run func(ctx context.Context, ref string, releaseId string) error) *KitDistributedLockStorage_UnLock_Call {
	_c.Call.Return(run)
	return _c
}

// NewKitDistributedLock creates a new instance of KitDistributedLock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKitDistributedLock(t interface {
	mock.TestingT
	Cleanup(func())
}) *KitDistributedLock {
	mock := &KitDistributedLock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KitDistributedLock is an autogenerated mock type for the DistributedLock type
type KitDistributedLock struct {
	mock.Mock
}

type KitDistributedLock_Expecter struct {
	mock *mock.Mock
}

func (_m *KitDistributedLock) EXPECT() *KitDistributedLock_Expecter {
	return &KitDistributedLock_Expecter{mock: &_m.Mock}
}

// Lock provides a mock function for the type KitDistributedLock
func (_mock *KitDistributedLock) Lock(ctx context.Context, ref string) (string, error) {
	ret := _mock.Called(ctx, ref)

	if len(ret) == 0 {
		panic("no return value specified for Lock")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return returnFunc(ctx, ref)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = returnFunc(ctx, ref)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, ref)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// KitDistributedLock_Lock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Lock'
type KitDistributedLock_Lock_Call struct {
	*mock.Call
}

// Lock is a helper method to define mock.On call
//   - ctx
//   - ref
func (_e *KitDistributedLock_Expecter) Lock(ctx interface{}, ref interface{}) *KitDistributedLock_Lock_Call {
	return &KitDistributedLock_Lock_Call{Call: _e.mock.On("Lock", ctx, ref)}
}

func (_c *KitDistributedLock_Lock_Call) Run(run func(ctx context.Context, ref string)) *KitDistributedLock_Lock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *KitDistributedLock_Lock_Call) Return(s string, err error) *KitDistributedLock_Lock_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *KitDistributedLock_Lock_Call) RunAndReturn(run func(ctx context.Context, ref string) (string, error)) *KitDistributedLock_Lock_Call {
	_c.Call.Return(run)
	return _c
}

// UnLock provides a mock function for the type KitDistributedLock
func (_mock *KitDistributedLock) UnLock(ctx context.Context, ref string, releaseId string) {
	_mock.Called(ctx, ref, releaseId)
	return
}

// KitDistributedLock_UnLock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnLock'
type KitDistributedLock_UnLock_Call struct {
	*mock.Call
}

// UnLock is a helper method to define mock.On call
//   - ctx
//   - ref
//   - releaseId
func (_e *KitDistributedLock_Expecter) UnLock(ctx interface{}, ref interface{}, releaseId interface{}) *KitDistributedLock_UnLock_Call {
	return &KitDistributedLock_UnLock_Call{Call: _e.mock.On("UnLock", ctx, ref, releaseId)}
}

func (_c *KitDistributedLock_UnLock_Call) Run(run func(ctx context.Context, ref string, releaseId string)) *KitDistributedLock_UnLock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *KitDistributedLock_UnLock_Call) Return() *KitDistributedLock_UnLock_Call {
	_c.Call.Return()
	return _c
}

func (_c *KitDistributedLock_UnLock_Call) RunAndReturn(run func(ctx context.Context, ref string, releaseId string)) *KitDistributedLock_UnLock_Call {
	_c.Run(run)
	return _c
}

// NewKitErrorHook creates a new instance of KitErrorHook. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKitErrorHook(t interface {
	mock.TestingT
	Cleanup(func())
}) *KitErrorHook {
	mock := &KitErrorHook{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KitErrorHook is an autogenerated mock type for the ErrorHook type
type KitErrorHook struct {
	mock.Mock
}

type KitErrorHook_Expecter struct {
	mock *mock.Mock
}

func (_m *KitErrorHook) EXPECT() *KitErrorHook_Expecter {
	return &KitErrorHook_Expecter{mock: &_m.Mock}
}

// Error provides a mock function for the type KitErrorHook
func (_mock *KitErrorHook) Error(err error) {
	_mock.Called(err)
	return
}

// KitErrorHook_Error_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Error'
type KitErrorHook_Error_Call struct {
	*mock.Call
}

// Error is a helper method to define mock.On call
//   - err
func (_e *KitErrorHook_Expecter) Error(err interface{}) *KitErrorHook_Error_Call {
	return &KitErrorHook_Error_Call{Call: _e.mock.On("Error", err)}
}

func (_c *KitErrorHook_Error_Call) Run(run func(err error)) *KitErrorHook_Error_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(error))
	})
	return _c
}

func (_c *KitErrorHook_Error_Call) Return() *KitErrorHook_Error_Call {
	_c.Call.Return()
	return _c
}

func (_c *KitErrorHook_Error_Call) RunAndReturn(run func(err error)) *KitErrorHook_Error_Call {
	_c.Run(run)
	return _c
}

// NewKitCLogger creates a new instance of KitCLogger. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKitCLogger(t interface {
	mock.TestingT
	Cleanup(func())
}) *KitCLogger {
	mock := &KitCLogger{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KitCLogger is an autogenerated mock type for the CLogger type
type KitCLogger struct {
	mock.Mock
}

type KitCLogger_Expecter struct {
	mock *mock.Mock
}

func (_m *KitCLogger) EXPECT() *KitCLogger_Expecter {
	return &KitCLogger_Expecter{mock: &_m.Mock}
}

// C provides a mock function for the type KitCLogger
func (_mock *KitCLogger) C(ctx context.Context) kit.CLogger {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for C")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(context.Context) kit.CLogger); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_C_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'C'
type KitCLogger_C_Call struct {
	*mock.Call
}

// C is a helper method to define mock.On call
//   - ctx
func (_e *KitCLogger_Expecter) C(ctx interface{}) *KitCLogger_C_Call {
	return &KitCLogger_C_Call{Call: _e.mock.On("C", ctx)}
}

func (_c *KitCLogger_C_Call) Run(run func(ctx context.Context)) *KitCLogger_C_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *KitCLogger_C_Call) Return(cLogger kit.CLogger) *KitCLogger_C_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_C_Call) RunAndReturn(run func(ctx context.Context) kit.CLogger) *KitCLogger_C_Call {
	_c.Call.Return(run)
	return _c
}

// Clone provides a mock function for the type KitCLogger
func (_mock *KitCLogger) Clone() kit.CLogger {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Clone")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func() kit.CLogger); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_Clone_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clone'
type KitCLogger_Clone_Call struct {
	*mock.Call
}

// Clone is a helper method to define mock.On call
func (_e *KitCLogger_Expecter) Clone() *KitCLogger_Clone_Call {
	return &KitCLogger_Clone_Call{Call: _e.mock.On("Clone")}
}

func (_c *KitCLogger_Clone_Call) Run(run func()) *KitCLogger_Clone_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KitCLogger_Clone_Call) Return(cLogger kit.CLogger) *KitCLogger_Clone_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_Clone_Call) RunAndReturn(run func() kit.CLogger) *KitCLogger_Clone_Call {
	_c.Call.Return(run)
	return _c
}

// Cmp provides a mock function for the type KitCLogger
func (_mock *KitCLogger) Cmp(c string) kit.CLogger {
	ret := _mock.Called(c)

	if len(ret) == 0 {
		panic("no return value specified for Cmp")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(string) kit.CLogger); ok {
		r0 = returnFunc(c)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_Cmp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Cmp'
type KitCLogger_Cmp_Call struct {
	*mock.Call
}

// Cmp is a helper method to define mock.On call
//   - c
func (_e *KitCLogger_Expecter) Cmp(c interface{}) *KitCLogger_Cmp_Call {
	return &KitCLogger_Cmp_Call{Call: _e.mock.On("Cmp", c)}
}

func (_c *KitCLogger_Cmp_Call) Run(run func(c string)) *KitCLogger_Cmp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *KitCLogger_Cmp_Call) Return(cLogger kit.CLogger) *KitCLogger_Cmp_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_Cmp_Call) RunAndReturn(run func(c string) kit.CLogger) *KitCLogger_Cmp_Call {
	_c.Call.Return(run)
	return _c
}

// Dbg provides a mock function for the type KitCLogger
func (_mock *KitCLogger) Dbg(args ...interface{}) kit.CLogger {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(args)
	} else {
		tmpRet = _mock.Called()
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Dbg")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(...interface{}) kit.CLogger); ok {
		r0 = returnFunc(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_Dbg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Dbg'
type KitCLogger_Dbg_Call struct {
	*mock.Call
}

// Dbg is a helper method to define mock.On call
//   - args
func (_e *KitCLogger_Expecter) Dbg(args ...interface{}) *KitCLogger_Dbg_Call {
	return &KitCLogger_Dbg_Call{Call: _e.mock.On("Dbg",
		append([]interface{}{}, args...)...)}
}

func (_c *KitCLogger_Dbg_Call) Run(run func(args ...interface{})) *KitCLogger_Dbg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[0].([]interface{})
		run(variadicArgs...)
	})
	return _c
}

func (_c *KitCLogger_Dbg_Call) Return(cLogger kit.CLogger) *KitCLogger_Dbg_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_Dbg_Call) RunAndReturn(run func(args ...interface{}) kit.CLogger) *KitCLogger_Dbg_Call {
	_c.Call.Return(run)
	return _c
}

// DbgF provides a mock function for the type KitCLogger
func (_mock *KitCLogger) DbgF(format string, args ...interface{}) kit.CLogger {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(format, args)
	} else {
		tmpRet = _mock.Called(format)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DbgF")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(string, ...interface{}) kit.CLogger); ok {
		r0 = returnFunc(format, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_DbgF_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DbgF'
type KitCLogger_DbgF_Call struct {
	*mock.Call
}

// DbgF is a helper method to define mock.On call
//   - format
//   - args
func (_e *KitCLogger_Expecter) DbgF(format interface{}, args ...interface{}) *KitCLogger_DbgF_Call {
	return &KitCLogger_DbgF_Call{Call: _e.mock.On("DbgF",
		append([]interface{}{format}, args...)...)}
}

func (_c *KitCLogger_DbgF_Call) Run(run func(format string, args ...interface{})) *KitCLogger_DbgF_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[1].([]interface{})
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *KitCLogger_DbgF_Call) Return(cLogger kit.CLogger) *KitCLogger_DbgF_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_DbgF_Call) RunAndReturn(run func(format string, args ...interface{}) kit.CLogger) *KitCLogger_DbgF_Call {
	_c.Call.Return(run)
	return _c
}

// E provides a mock function for the type KitCLogger
func (_mock *KitCLogger) E(err error) kit.CLogger {
	ret := _mock.Called(err)

	if len(ret) == 0 {
		panic("no return value specified for E")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(error) kit.CLogger); ok {
		r0 = returnFunc(err)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_E_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'E'
type KitCLogger_E_Call struct {
	*mock.Call
}

// E is a helper method to define mock.On call
//   - err
func (_e *KitCLogger_Expecter) E(err interface{}) *KitCLogger_E_Call {
	return &KitCLogger_E_Call{Call: _e.mock.On("E", err)}
}

func (_c *KitCLogger_E_Call) Run(run func(err error)) *KitCLogger_E_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(error))
	})
	return _c
}

func (_c *KitCLogger_E_Call) Return(cLogger kit.CLogger) *KitCLogger_E_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_E_Call) RunAndReturn(run func(err error) kit.CLogger) *KitCLogger_E_Call {
	_c.Call.Return(run)
	return _c
}

// Err provides a mock function for the type KitCLogger
func (_mock *KitCLogger) Err(args ...interface{}) kit.CLogger {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(args)
	} else {
		tmpRet = _mock.Called()
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Err")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(...interface{}) kit.CLogger); ok {
		r0 = returnFunc(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_Err_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Err'
type KitCLogger_Err_Call struct {
	*mock.Call
}

// Err is a helper method to define mock.On call
//   - args
func (_e *KitCLogger_Expecter) Err(args ...interface{}) *KitCLogger_Err_Call {
	return &KitCLogger_Err_Call{Call: _e.mock.On("Err",
		append([]interface{}{}, args...)...)}
}

func (_c *KitCLogger_Err_Call) Run(run func(args ...interface{})) *KitCLogger_Err_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[0].([]interface{})
		run(variadicArgs...)
	})
	return _c
}

func (_c *KitCLogger_Err_Call) Return(cLogger kit.CLogger) *KitCLogger_Err_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_Err_Call) RunAndReturn(run func(args ...interface{}) kit.CLogger) *KitCLogger_Err_Call {
	_c.Call.Return(run)
	return _c
}

// ErrF provides a mock function for the type KitCLogger
func (_mock *KitCLogger) ErrF(format string, args ...interface{}) kit.CLogger {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(format, args)
	} else {
		tmpRet = _mock.Called(format)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ErrF")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(string, ...interface{}) kit.CLogger); ok {
		r0 = returnFunc(format, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_ErrF_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ErrF'
type KitCLogger_ErrF_Call struct {
	*mock.Call
}

// ErrF is a helper method to define mock.On call
//   - format
//   - args
func (_e *KitCLogger_Expecter) ErrF(format interface{}, args ...interface{}) *KitCLogger_ErrF_Call {
	return &KitCLogger_ErrF_Call{Call: _e.mock.On("ErrF",
		append([]interface{}{format}, args...)...)}
}

func (_c *KitCLogger_ErrF_Call) Run(run func(format string, args ...interface{})) *KitCLogger_ErrF_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[1].([]interface{})
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *KitCLogger_ErrF_Call) Return(cLogger kit.CLogger) *KitCLogger_ErrF_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_ErrF_Call) RunAndReturn(run func(format string, args ...interface{}) kit.CLogger) *KitCLogger_ErrF_Call {
	_c.Call.Return(run)
	return _c
}

// F provides a mock function for the type KitCLogger
func (_mock *KitCLogger) F(fields kit.KV) kit.CLogger {
	ret := _mock.Called(fields)

	if len(ret) == 0 {
		panic("no return value specified for F")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(kit.KV) kit.CLogger); ok {
		r0 = returnFunc(fields)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_F_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'F'
type KitCLogger_F_Call struct {
	*mock.Call
}

// F is a helper method to define mock.On call
//   - fields
func (_e *KitCLogger_Expecter) F(fields interface{}) *KitCLogger_F_Call {
	return &KitCLogger_F_Call{Call: _e.mock.On("F", fields)}
}

func (_c *KitCLogger_F_Call) Run(run func(fields kit.KV)) *KitCLogger_F_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(kit.KV))
	})
	return _c
}

func (_c *KitCLogger_F_Call) Return(cLogger kit.CLogger) *KitCLogger_F_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_F_Call) RunAndReturn(run func(fields kit.KV) kit.CLogger) *KitCLogger_F_Call {
	_c.Call.Return(run)
	return _c
}

// Fatal provides a mock function for the type KitCLogger
func (_mock *KitCLogger) Fatal(args ...interface{}) kit.CLogger {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(args)
	} else {
		tmpRet = _mock.Called()
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Fatal")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(...interface{}) kit.CLogger); ok {
		r0 = returnFunc(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_Fatal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Fatal'
type KitCLogger_Fatal_Call struct {
	*mock.Call
}

// Fatal is a helper method to define mock.On call
//   - args
func (_e *KitCLogger_Expecter) Fatal(args ...interface{}) *KitCLogger_Fatal_Call {
	return &KitCLogger_Fatal_Call{Call: _e.mock.On("Fatal",
		append([]interface{}{}, args...)...)}
}

func (_c *KitCLogger_Fatal_Call) Run(run func(args ...interface{})) *KitCLogger_Fatal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[0].([]interface{})
		run(variadicArgs...)
	})
	return _c
}

func (_c *KitCLogger_Fatal_Call) Return(cLogger kit.CLogger) *KitCLogger_Fatal_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_Fatal_Call) RunAndReturn(run func(args ...interface{}) kit.CLogger) *KitCLogger_Fatal_Call {
	_c.Call.Return(run)
	return _c
}

// FatalF provides a mock function for the type KitCLogger
func (_mock *KitCLogger) FatalF(format string, args ...interface{}) kit.CLogger {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(format, args)
	} else {
		tmpRet = _mock.Called(format)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for FatalF")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(string, ...interface{}) kit.CLogger); ok {
		r0 = returnFunc(format, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_FatalF_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FatalF'
type KitCLogger_FatalF_Call struct {
	*mock.Call
}

// FatalF is a helper method to define mock.On call
//   - format
//   - args
func (_e *KitCLogger_Expecter) FatalF(format interface{}, args ...interface{}) *KitCLogger_FatalF_Call {
	return &KitCLogger_FatalF_Call{Call: _e.mock.On("FatalF",
		append([]interface{}{format}, args...)...)}
}

func (_c *KitCLogger_FatalF_Call) Run(run func(format string, args ...interface{})) *KitCLogger_FatalF_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[1].([]interface{})
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *KitCLogger_FatalF_Call) Return(cLogger kit.CLogger) *KitCLogger_FatalF_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_FatalF_Call) RunAndReturn(run func(format string, args ...interface{}) kit.CLogger) *KitCLogger_FatalF_Call {
	_c.Call.Return(run)
	return _c
}

// Inf provides a mock function for the type KitCLogger
func (_mock *KitCLogger) Inf(args ...interface{}) kit.CLogger {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(args)
	} else {
		tmpRet = _mock.Called()
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Inf")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(...interface{}) kit.CLogger); ok {
		r0 = returnFunc(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_Inf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Inf'
type KitCLogger_Inf_Call struct {
	*mock.Call
}

// Inf is a helper method to define mock.On call
//   - args
func (_e *KitCLogger_Expecter) Inf(args ...interface{}) *KitCLogger_Inf_Call {
	return &KitCLogger_Inf_Call{Call: _e.mock.On("Inf",
		append([]interface{}{}, args...)...)}
}

func (_c *KitCLogger_Inf_Call) Run(run func(args ...interface{})) *KitCLogger_Inf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[0].([]interface{})
		run(variadicArgs...)
	})
	return _c
}

func (_c *KitCLogger_Inf_Call) Return(cLogger kit.CLogger) *KitCLogger_Inf_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_Inf_Call) RunAndReturn(run func(args ...interface{}) kit.CLogger) *KitCLogger_Inf_Call {
	_c.Call.Return(run)
	return _c
}

// InfF provides a mock function for the type KitCLogger
func (_mock *KitCLogger) InfF(format string, args ...interface{}) kit.CLogger {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(format, args)
	} else {
		tmpRet = _mock.Called(format)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for InfF")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(string, ...interface{}) kit.CLogger); ok {
		r0 = returnFunc(format, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_InfF_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfF'
type KitCLogger_InfF_Call struct {
	*mock.Call
}

// InfF is a helper method to define mock.On call
//   - format
//   - args
func (_e *KitCLogger_Expecter) InfF(format interface{}, args ...interface{}) *KitCLogger_InfF_Call {
	return &KitCLogger_InfF_Call{Call: _e.mock.On("InfF",
		append([]interface{}{format}, args...)...)}
}

func (_c *KitCLogger_InfF_Call) Run(run func(format string, args ...interface{})) *KitCLogger_InfF_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[1].([]interface{})
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *KitCLogger_InfF_Call) Return(cLogger kit.CLogger) *KitCLogger_InfF_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_InfF_Call) RunAndReturn(run func(format string, args ...interface{}) kit.CLogger) *KitCLogger_InfF_Call {
	_c.Call.Return(run)
	return _c
}

// Mth provides a mock function for the type KitCLogger
func (_mock *KitCLogger) Mth(m string) kit.CLogger {
	ret := _mock.Called(m)

	if len(ret) == 0 {
		panic("no return value specified for Mth")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(string) kit.CLogger); ok {
		r0 = returnFunc(m)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_Mth_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Mth'
type KitCLogger_Mth_Call struct {
	*mock.Call
}

// Mth is a helper method to define mock.On call
//   - m
func (_e *KitCLogger_Expecter) Mth(m interface{}) *KitCLogger_Mth_Call {
	return &KitCLogger_Mth_Call{Call: _e.mock.On("Mth", m)}
}

func (_c *KitCLogger_Mth_Call) Run(run func(m string)) *KitCLogger_Mth_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *KitCLogger_Mth_Call) Return(cLogger kit.CLogger) *KitCLogger_Mth_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_Mth_Call) RunAndReturn(run func(m string) kit.CLogger) *KitCLogger_Mth_Call {
	_c.Call.Return(run)
	return _c
}

// Node provides a mock function for the type KitCLogger
func (_mock *KitCLogger) Node(n string) kit.CLogger {
	ret := _mock.Called(n)

	if len(ret) == 0 {
		panic("no return value specified for Node")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(string) kit.CLogger); ok {
		r0 = returnFunc(n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_Node_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Node'
type KitCLogger_Node_Call struct {
	*mock.Call
}

// Node is a helper method to define mock.On call
//   - n
func (_e *KitCLogger_Expecter) Node(n interface{}) *KitCLogger_Node_Call {
	return &KitCLogger_Node_Call{Call: _e.mock.On("Node", n)}
}

func (_c *KitCLogger_Node_Call) Run(run func(n string)) *KitCLogger_Node_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *KitCLogger_Node_Call) Return(cLogger kit.CLogger) *KitCLogger_Node_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_Node_Call) RunAndReturn(run func(n string) kit.CLogger) *KitCLogger_Node_Call {
	_c.Call.Return(run)
	return _c
}

// Pr provides a mock function for the type KitCLogger
func (_mock *KitCLogger) Pr(m string) kit.CLogger {
	ret := _mock.Called(m)

	if len(ret) == 0 {
		panic("no return value specified for Pr")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(string) kit.CLogger); ok {
		r0 = returnFunc(m)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_Pr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pr'
type KitCLogger_Pr_Call struct {
	*mock.Call
}

// Pr is a helper method to define mock.On call
//   - m
func (_e *KitCLogger_Expecter) Pr(m interface{}) *KitCLogger_Pr_Call {
	return &KitCLogger_Pr_Call{Call: _e.mock.On("Pr", m)}
}

func (_c *KitCLogger_Pr_Call) Run(run func(m string)) *KitCLogger_Pr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *KitCLogger_Pr_Call) Return(cLogger kit.CLogger) *KitCLogger_Pr_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_Pr_Call) RunAndReturn(run func(m string) kit.CLogger) *KitCLogger_Pr_Call {
	_c.Call.Return(run)
	return _c
}

// Printf provides a mock function for the type KitCLogger
func (_mock *KitCLogger) Printf(format string, args ...interface{}) {
	if len(args) > 0 {
		_mock.Called(format, args)
	} else {
		_mock.Called(format)
	}

	return
}

// KitCLogger_Printf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Printf'
type KitCLogger_Printf_Call struct {
	*mock.Call
}

// Printf is a helper method to define mock.On call
//   - format
//   - args
func (_e *KitCLogger_Expecter) Printf(format interface{}, args ...interface{}) *KitCLogger_Printf_Call {
	return &KitCLogger_Printf_Call{Call: _e.mock.On("Printf",
		append([]interface{}{format}, args...)...)}
}

func (_c *KitCLogger_Printf_Call) Run(run func(format string, args ...interface{})) *KitCLogger_Printf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[1].([]interface{})
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *KitCLogger_Printf_Call) Return() *KitCLogger_Printf_Call {
	_c.Call.Return()
	return _c
}

func (_c *KitCLogger_Printf_Call) RunAndReturn(run func(format string, args ...interface{})) *KitCLogger_Printf_Call {
	_c.Run(run)
	return _c
}

// PrintfErr provides a mock function for the type KitCLogger
func (_mock *KitCLogger) PrintfErr(format string, args ...interface{}) {
	if len(args) > 0 {
		_mock.Called(format, args)
	} else {
		_mock.Called(format)
	}

	return
}

// KitCLogger_PrintfErr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PrintfErr'
type KitCLogger_PrintfErr_Call struct {
	*mock.Call
}

// PrintfErr is a helper method to define mock.On call
//   - format
//   - args
func (_e *KitCLogger_Expecter) PrintfErr(format interface{}, args ...interface{}) *KitCLogger_PrintfErr_Call {
	return &KitCLogger_PrintfErr_Call{Call: _e.mock.On("PrintfErr",
		append([]interface{}{format}, args...)...)}
}

func (_c *KitCLogger_PrintfErr_Call) Run(run func(format string, args ...interface{})) *KitCLogger_PrintfErr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[1].([]interface{})
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *KitCLogger_PrintfErr_Call) Return() *KitCLogger_PrintfErr_Call {
	_c.Call.Return()
	return _c
}

func (_c *KitCLogger_PrintfErr_Call) RunAndReturn(run func(format string, args ...interface{})) *KitCLogger_PrintfErr_Call {
	_c.Run(run)
	return _c
}

// Srv provides a mock function for the type KitCLogger
func (_mock *KitCLogger) Srv(s string) kit.CLogger {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for Srv")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(string) kit.CLogger); ok {
		r0 = returnFunc(s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_Srv_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Srv'
type KitCLogger_Srv_Call struct {
	*mock.Call
}

// Srv is a helper method to define mock.On call
//   - s
func (_e *KitCLogger_Expecter) Srv(s interface{}) *KitCLogger_Srv_Call {
	return &KitCLogger_Srv_Call{Call: _e.mock.On("Srv", s)}
}

func (_c *KitCLogger_Srv_Call) Run(run func(s string)) *KitCLogger_Srv_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *KitCLogger_Srv_Call) Return(cLogger kit.CLogger) *KitCLogger_Srv_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_Srv_Call) RunAndReturn(run func(s string) kit.CLogger) *KitCLogger_Srv_Call {
	_c.Call.Return(run)
	return _c
}

// St provides a mock function for the type KitCLogger
func (_mock *KitCLogger) St() kit.CLogger {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for St")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func() kit.CLogger); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_St_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'St'
type KitCLogger_St_Call struct {
	*mock.Call
}

// St is a helper method to define mock.On call
func (_e *KitCLogger_Expecter) St() *KitCLogger_St_Call {
	return &KitCLogger_St_Call{Call: _e.mock.On("St")}
}

func (_c *KitCLogger_St_Call) Run(run func()) *KitCLogger_St_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KitCLogger_St_Call) Return(cLogger kit.CLogger) *KitCLogger_St_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_St_Call) RunAndReturn(run func() kit.CLogger) *KitCLogger_St_Call {
	_c.Call.Return(run)
	return _c
}

// Trc provides a mock function for the type KitCLogger
func (_mock *KitCLogger) Trc(args ...interface{}) kit.CLogger {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(args)
	} else {
		tmpRet = _mock.Called()
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Trc")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(...interface{}) kit.CLogger); ok {
		r0 = returnFunc(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_Trc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Trc'
type KitCLogger_Trc_Call struct {
	*mock.Call
}

// Trc is a helper method to define mock.On call
//   - args
func (_e *KitCLogger_Expecter) Trc(args ...interface{}) *KitCLogger_Trc_Call {
	return &KitCLogger_Trc_Call{Call: _e.mock.On("Trc",
		append([]interface{}{}, args...)...)}
}

func (_c *KitCLogger_Trc_Call) Run(run func(args ...interface{})) *KitCLogger_Trc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[0].([]interface{})
		run(variadicArgs...)
	})
	return _c
}

func (_c *KitCLogger_Trc_Call) Return(cLogger kit.CLogger) *KitCLogger_Trc_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_Trc_Call) RunAndReturn(run func(args ...interface{}) kit.CLogger) *KitCLogger_Trc_Call {
	_c.Call.Return(run)
	return _c
}

// TrcF provides a mock function for the type KitCLogger
func (_mock *KitCLogger) TrcF(format string, args ...interface{}) kit.CLogger {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(format, args)
	} else {
		tmpRet = _mock.Called(format)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for TrcF")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(string, ...interface{}) kit.CLogger); ok {
		r0 = returnFunc(format, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_TrcF_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TrcF'
type KitCLogger_TrcF_Call struct {
	*mock.Call
}

// TrcF is a helper method to define mock.On call
//   - format
//   - args
func (_e *KitCLogger_Expecter) TrcF(format interface{}, args ...interface{}) *KitCLogger_TrcF_Call {
	return &KitCLogger_TrcF_Call{Call: _e.mock.On("TrcF",
		append([]interface{}{format}, args...)...)}
}

func (_c *KitCLogger_TrcF_Call) Run(run func(format string, args ...interface{})) *KitCLogger_TrcF_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[1].([]interface{})
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *KitCLogger_TrcF_Call) Return(cLogger kit.CLogger) *KitCLogger_TrcF_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_TrcF_Call) RunAndReturn(run func(format string, args ...interface{}) kit.CLogger) *KitCLogger_TrcF_Call {
	_c.Call.Return(run)
	return _c
}

// TrcObj provides a mock function for the type KitCLogger
func (_mock *KitCLogger) TrcObj(format string, args ...interface{}) kit.CLogger {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(format, args)
	} else {
		tmpRet = _mock.Called(format)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for TrcObj")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(string, ...interface{}) kit.CLogger); ok {
		r0 = returnFunc(format, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_TrcObj_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TrcObj'
type KitCLogger_TrcObj_Call struct {
	*mock.Call
}

// TrcObj is a helper method to define mock.On call
//   - format
//   - args
func (_e *KitCLogger_Expecter) TrcObj(format interface{}, args ...interface{}) *KitCLogger_TrcObj_Call {
	return &KitCLogger_TrcObj_Call{Call: _e.mock.On("TrcObj",
		append([]interface{}{format}, args...)...)}
}

func (_c *KitCLogger_TrcObj_Call) Run(run func(format string, args ...interface{})) *KitCLogger_TrcObj_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[1].([]interface{})
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *KitCLogger_TrcObj_Call) Return(cLogger kit.CLogger) *KitCLogger_TrcObj_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_TrcObj_Call) RunAndReturn(run func(format string, args ...interface{}) kit.CLogger) *KitCLogger_TrcObj_Call {
	_c.Call.Return(run)
	return _c
}

// Warn provides a mock function for the type KitCLogger
func (_mock *KitCLogger) Warn(args ...interface{}) kit.CLogger {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(args)
	} else {
		tmpRet = _mock.Called()
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Warn")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(...interface{}) kit.CLogger); ok {
		r0 = returnFunc(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_Warn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Warn'
type KitCLogger_Warn_Call struct {
	*mock.Call
}

// Warn is a helper method to define mock.On call
//   - args
func (_e *KitCLogger_Expecter) Warn(args ...interface{}) *KitCLogger_Warn_Call {
	return &KitCLogger_Warn_Call{Call: _e.mock.On("Warn",
		append([]interface{}{}, args...)...)}
}

func (_c *KitCLogger_Warn_Call) Run(run func(args ...interface{})) *KitCLogger_Warn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[0].([]interface{})
		run(variadicArgs...)
	})
	return _c
}

func (_c *KitCLogger_Warn_Call) Return(cLogger kit.CLogger) *KitCLogger_Warn_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_Warn_Call) RunAndReturn(run func(args ...interface{}) kit.CLogger) *KitCLogger_Warn_Call {
	_c.Call.Return(run)
	return _c
}

// WarnF provides a mock function for the type KitCLogger
func (_mock *KitCLogger) WarnF(format string, args ...interface{}) kit.CLogger {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(format, args)
	} else {
		tmpRet = _mock.Called(format)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for WarnF")
	}

	var r0 kit.CLogger
	if returnFunc, ok := ret.Get(0).(func(string, ...interface{}) kit.CLogger); ok {
		r0 = returnFunc(format, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kit.CLogger)
		}
	}
	return r0
}

// KitCLogger_WarnF_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WarnF'
type KitCLogger_WarnF_Call struct {
	*mock.Call
}

// WarnF is a helper method to define mock.On call
//   - format
//   - args
func (_e *KitCLogger_Expecter) WarnF(format interface{}, args ...interface{}) *KitCLogger_WarnF_Call {
	return &KitCLogger_WarnF_Call{Call: _e.mock.On("WarnF",
		append([]interface{}{format}, args...)...)}
}

func (_c *KitCLogger_WarnF_Call) Run(run func(format string, args ...interface{})) *KitCLogger_WarnF_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[1].([]interface{})
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *KitCLogger_WarnF_Call) Return(cLogger kit.CLogger) *KitCLogger_WarnF_Call {
	_c.Call.Return(cLogger)
	return _c
}

func (_c *KitCLogger_WarnF_Call) RunAndReturn(run func(format string, args ...interface{}) kit.CLogger) *KitCLogger_WarnF_Call {
	_c.Call.Return(run)
	return _c
}

// Write provides a mock function for the type KitCLogger
func (_mock *KitCLogger) Write(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Write")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// KitCLogger_Write_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Write'
type KitCLogger_Write_Call struct {
	*mock.Call
}

// Write is a helper method to define mock.On call
//   - p
func (_e *KitCLogger_Expecter) Write(p interface{}) *KitCLogger_Write_Call {
	return &KitCLogger_Write_Call{Call: _e.mock.On("Write", p)}
}

func (_c *KitCLogger_Write_Call) Run(run func(p []byte)) *KitCLogger_Write_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *KitCLogger_Write_Call) Return(n int, err error) *KitCLogger_Write_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *KitCLogger_Write_Call) RunAndReturn(run func(p []byte) (int, error)) *KitCLogger_Write_Call {
	_c.Call.Return(run)
	return _c
}

// NewKitPlainType creates a new instance of KitPlainType. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKitPlainType(t interface {
	mock.TestingT
	Cleanup(func())
}) *KitPlainType {
	mock := &KitPlainType{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KitPlainType is an autogenerated mock type for the PlainType type
type KitPlainType struct {
	mock.Mock
}

type KitPlainType_Expecter struct {
	mock *mock.Mock
}

func (_m *KitPlainType) EXPECT() *KitPlainType_Expecter {
	return &KitPlainType_Expecter{mock: &_m.Mock}
}

// NewKitPageReader creates a new instance of KitPageReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKitPageReader[TItem any, TRq any](t interface {
	mock.TestingT
	Cleanup(func())
}) *KitPageReader[TItem, TRq] {
	mock := &KitPageReader[TItem, TRq]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KitPageReader is an autogenerated mock type for the PageReader type
type KitPageReader[TItem any, TRq any] struct {
	mock.Mock
}

type KitPageReader_Expecter[TItem any, TRq any] struct {
	mock *mock.Mock
}

func (_m *KitPageReader[TItem, TRq]) EXPECT() *KitPageReader_Expecter[TItem, TRq] {
	return &KitPageReader_Expecter[TItem, TRq]{mock: &_m.Mock}
}

// GetPage provides a mock function for the type KitPageReader
func (_mock *KitPageReader[TItem, TRq]) GetPage(ctx context.Context, rq TRq) chan kit.PagingResponseG[TItem] {
	ret := _mock.Called(ctx, rq)

	if len(ret) == 0 {
		panic("no return value specified for GetPage")
	}

	var r0 chan kit.PagingResponseG[TItem]
	if returnFunc, ok := ret.Get(0).(func(context.Context, TRq) chan kit.PagingResponseG[TItem]); ok {
		r0 = returnFunc(ctx, rq)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan kit.PagingResponseG[TItem])
		}
	}
	return r0
}

// KitPageReader_GetPage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPage'
type KitPageReader_GetPage_Call[TItem any, TRq any] struct {
	*mock.Call
}

// GetPage is a helper method to define mock.On call
//   - ctx
//   - rq
func (_e *KitPageReader_Expecter[TItem, TRq]) GetPage(ctx interface{}, rq interface{}) *KitPageReader_GetPage_Call[TItem, TRq] {
	return &KitPageReader_GetPage_Call[TItem, TRq]{Call: _e.mock.On("GetPage", ctx, rq)}
}

func (_c *KitPageReader_GetPage_Call[TItem, TRq]) Run(run func(ctx context.Context, rq TRq)) *KitPageReader_GetPage_Call[TItem, TRq] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(TRq))
	})
	return _c
}

func (_c *KitPageReader_GetPage_Call[TItem, TRq]) Return(pagingResponseGCh chan kit.PagingResponseG[TItem]) *KitPageReader_GetPage_Call[TItem, TRq] {
	_c.Call.Return(pagingResponseGCh)
	return _c
}

func (_c *KitPageReader_GetPage_Call[TItem, TRq]) RunAndReturn(run func(ctx context.Context, rq TRq) chan kit.PagingResponseG[TItem]) *KitPageReader_GetPage_Call[TItem, TRq] {
	_c.Call.Return(run)
	return _c
}

// NewKitTFlags creates a new instance of KitTFlags. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKitTFlags(t interface {
	mock.TestingT
	Cleanup(func())
}) *KitTFlags {
	mock := &KitTFlags{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KitTFlags is an autogenerated mock type for the TFlags type
type KitTFlags struct {
	mock.Mock
}

type KitTFlags_Expecter struct {
	mock *mock.Mock
}

func (_m *KitTFlags) EXPECT() *KitTFlags_Expecter {
	return &KitTFlags_Expecter{mock: &_m.Mock}
}
