// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	mock "github.com/stretchr/testify/mock"
)

// NewEventBusSubscriber creates a new instance of EventBusSubscriber. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEventBusSubscriber(t interface {
	mock.TestingT
	Cleanup(func())
}) *EventBusSubscriber {
	mock := &EventBusSubscriber{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EventBusSubscriber is an autogenerated mock type for the BusSubscriber type
type EventBusSubscriber struct {
	mock.Mock
}

type EventBusSubscriber_Expecter struct {
	mock *mock.Mock
}

func (_m *EventBusSubscriber) EXPECT() *EventBusSubscriber_Expecter {
	return &EventBusSubscriber_Expecter{mock: &_m.Mock}
}

// Subscribe provides a mock function for the type EventBusSubscriber
func (_mock *EventBusSubscriber) Subscribe(topic string, fn interface{}) error {
	ret := _mock.Called(topic, fn)

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = returnFunc(topic, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EventBusSubscriber_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type EventBusSubscriber_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - topic
//   - fn
func (_e *EventBusSubscriber_Expecter) Subscribe(topic interface{}, fn interface{}) *EventBusSubscriber_Subscribe_Call {
	return &EventBusSubscriber_Subscribe_Call{Call: _e.mock.On("Subscribe", topic, fn)}
}

func (_c *EventBusSubscriber_Subscribe_Call) Run(run func(topic string, fn interface{})) *EventBusSubscriber_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *EventBusSubscriber_Subscribe_Call) Return(err error) *EventBusSubscriber_Subscribe_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EventBusSubscriber_Subscribe_Call) RunAndReturn(run func(topic string, fn interface{}) error) *EventBusSubscriber_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeAsync provides a mock function for the type EventBusSubscriber
func (_mock *EventBusSubscriber) SubscribeAsync(topic string, fn interface{}, transactional bool) error {
	ret := _mock.Called(topic, fn, transactional)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeAsync")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, interface{}, bool) error); ok {
		r0 = returnFunc(topic, fn, transactional)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EventBusSubscriber_SubscribeAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeAsync'
type EventBusSubscriber_SubscribeAsync_Call struct {
	*mock.Call
}

// SubscribeAsync is a helper method to define mock.On call
//   - topic
//   - fn
//   - transactional
func (_e *EventBusSubscriber_Expecter) SubscribeAsync(topic interface{}, fn interface{}, transactional interface{}) *EventBusSubscriber_SubscribeAsync_Call {
	return &EventBusSubscriber_SubscribeAsync_Call{Call: _e.mock.On("SubscribeAsync", topic, fn, transactional)}
}

func (_c *EventBusSubscriber_SubscribeAsync_Call) Run(run func(topic string, fn interface{}, transactional bool)) *EventBusSubscriber_SubscribeAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}), args[2].(bool))
	})
	return _c
}

func (_c *EventBusSubscriber_SubscribeAsync_Call) Return(err error) *EventBusSubscriber_SubscribeAsync_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EventBusSubscriber_SubscribeAsync_Call) RunAndReturn(run func(topic string, fn interface{}, transactional bool) error) *EventBusSubscriber_SubscribeAsync_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeOnce provides a mock function for the type EventBusSubscriber
func (_mock *EventBusSubscriber) SubscribeOnce(topic string, fn interface{}) error {
	ret := _mock.Called(topic, fn)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeOnce")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = returnFunc(topic, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EventBusSubscriber_SubscribeOnce_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeOnce'
type EventBusSubscriber_SubscribeOnce_Call struct {
	*mock.Call
}

// SubscribeOnce is a helper method to define mock.On call
//   - topic
//   - fn
func (_e *EventBusSubscriber_Expecter) SubscribeOnce(topic interface{}, fn interface{}) *EventBusSubscriber_SubscribeOnce_Call {
	return &EventBusSubscriber_SubscribeOnce_Call{Call: _e.mock.On("SubscribeOnce", topic, fn)}
}

func (_c *EventBusSubscriber_SubscribeOnce_Call) Run(run func(topic string, fn interface{})) *EventBusSubscriber_SubscribeOnce_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *EventBusSubscriber_SubscribeOnce_Call) Return(err error) *EventBusSubscriber_SubscribeOnce_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EventBusSubscriber_SubscribeOnce_Call) RunAndReturn(run func(topic string, fn interface{}) error) *EventBusSubscriber_SubscribeOnce_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeOnceAsync provides a mock function for the type EventBusSubscriber
func (_mock *EventBusSubscriber) SubscribeOnceAsync(topic string, fn interface{}) error {
	ret := _mock.Called(topic, fn)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeOnceAsync")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = returnFunc(topic, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EventBusSubscriber_SubscribeOnceAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeOnceAsync'
type EventBusSubscriber_SubscribeOnceAsync_Call struct {
	*mock.Call
}

// SubscribeOnceAsync is a helper method to define mock.On call
//   - topic
//   - fn
func (_e *EventBusSubscriber_Expecter) SubscribeOnceAsync(topic interface{}, fn interface{}) *EventBusSubscriber_SubscribeOnceAsync_Call {
	return &EventBusSubscriber_SubscribeOnceAsync_Call{Call: _e.mock.On("SubscribeOnceAsync", topic, fn)}
}

func (_c *EventBusSubscriber_SubscribeOnceAsync_Call) Run(run func(topic string, fn interface{})) *EventBusSubscriber_SubscribeOnceAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *EventBusSubscriber_SubscribeOnceAsync_Call) Return(err error) *EventBusSubscriber_SubscribeOnceAsync_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EventBusSubscriber_SubscribeOnceAsync_Call) RunAndReturn(run func(topic string, fn interface{}) error) *EventBusSubscriber_SubscribeOnceAsync_Call {
	_c.Call.Return(run)
	return _c
}

// Unsubscribe provides a mock function for the type EventBusSubscriber
func (_mock *EventBusSubscriber) Unsubscribe(topic string, handler interface{}) error {
	ret := _mock.Called(topic, handler)

	if len(ret) == 0 {
		panic("no return value specified for Unsubscribe")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = returnFunc(topic, handler)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EventBusSubscriber_Unsubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unsubscribe'
type EventBusSubscriber_Unsubscribe_Call struct {
	*mock.Call
}

// Unsubscribe is a helper method to define mock.On call
//   - topic
//   - handler
func (_e *EventBusSubscriber_Expecter) Unsubscribe(topic interface{}, handler interface{}) *EventBusSubscriber_Unsubscribe_Call {
	return &EventBusSubscriber_Unsubscribe_Call{Call: _e.mock.On("Unsubscribe", topic, handler)}
}

func (_c *EventBusSubscriber_Unsubscribe_Call) Run(run func(topic string, handler interface{})) *EventBusSubscriber_Unsubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *EventBusSubscriber_Unsubscribe_Call) Return(err error) *EventBusSubscriber_Unsubscribe_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EventBusSubscriber_Unsubscribe_Call) RunAndReturn(run func(topic string, handler interface{}) error) *EventBusSubscriber_Unsubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// NewEventBusPublisher creates a new instance of EventBusPublisher. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEventBusPublisher(t interface {
	mock.TestingT
	Cleanup(func())
}) *EventBusPublisher {
	mock := &EventBusPublisher{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EventBusPublisher is an autogenerated mock type for the BusPublisher type
type EventBusPublisher struct {
	mock.Mock
}

type EventBusPublisher_Expecter struct {
	mock *mock.Mock
}

func (_m *EventBusPublisher) EXPECT() *EventBusPublisher_Expecter {
	return &EventBusPublisher_Expecter{mock: &_m.Mock}
}

// Publish provides a mock function for the type EventBusPublisher
func (_mock *EventBusPublisher) Publish(ctx context.Context, topic string, args ...interface{}) {
	if len(args) > 0 {
		_mock.Called(ctx, topic, args)
	} else {
		_mock.Called(ctx, topic)
	}

	return
}

// EventBusPublisher_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type EventBusPublisher_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - ctx
//   - topic
//   - args
func (_e *EventBusPublisher_Expecter) Publish(ctx interface{}, topic interface{}, args ...interface{}) *EventBusPublisher_Publish_Call {
	return &EventBusPublisher_Publish_Call{Call: _e.mock.On("Publish",
		append([]interface{}{ctx, topic}, args...)...)}
}

func (_c *EventBusPublisher_Publish_Call) Run(run func(ctx context.Context, topic string, args ...interface{})) *EventBusPublisher_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[2].([]interface{})
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *EventBusPublisher_Publish_Call) Return() *EventBusPublisher_Publish_Call {
	_c.Call.Return()
	return _c
}

func (_c *EventBusPublisher_Publish_Call) RunAndReturn(run func(ctx context.Context, topic string, args ...interface{})) *EventBusPublisher_Publish_Call {
	_c.Run(run)
	return _c
}

// NewEventBusController creates a new instance of EventBusController. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEventBusController(t interface {
	mock.TestingT
	Cleanup(func())
}) *EventBusController {
	mock := &EventBusController{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EventBusController is an autogenerated mock type for the BusController type
type EventBusController struct {
	mock.Mock
}

type EventBusController_Expecter struct {
	mock *mock.Mock
}

func (_m *EventBusController) EXPECT() *EventBusController_Expecter {
	return &EventBusController_Expecter{mock: &_m.Mock}
}

// HasCallback provides a mock function for the type EventBusController
func (_mock *EventBusController) HasCallback(topic string) bool {
	ret := _mock.Called(topic)

	if len(ret) == 0 {
		panic("no return value specified for HasCallback")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(topic)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// EventBusController_HasCallback_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasCallback'
type EventBusController_HasCallback_Call struct {
	*mock.Call
}

// HasCallback is a helper method to define mock.On call
//   - topic
func (_e *EventBusController_Expecter) HasCallback(topic interface{}) *EventBusController_HasCallback_Call {
	return &EventBusController_HasCallback_Call{Call: _e.mock.On("HasCallback", topic)}
}

func (_c *EventBusController_HasCallback_Call) Run(run func(topic string)) *EventBusController_HasCallback_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *EventBusController_HasCallback_Call) Return(b bool) *EventBusController_HasCallback_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *EventBusController_HasCallback_Call) RunAndReturn(run func(topic string) bool) *EventBusController_HasCallback_Call {
	_c.Call.Return(run)
	return _c
}

// WaitAsync provides a mock function for the type EventBusController
func (_mock *EventBusController) WaitAsync() {
	_mock.Called()
	return
}

// EventBusController_WaitAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitAsync'
type EventBusController_WaitAsync_Call struct {
	*mock.Call
}

// WaitAsync is a helper method to define mock.On call
func (_e *EventBusController_Expecter) WaitAsync() *EventBusController_WaitAsync_Call {
	return &EventBusController_WaitAsync_Call{Call: _e.mock.On("WaitAsync")}
}

func (_c *EventBusController_WaitAsync_Call) Run(run func()) *EventBusController_WaitAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EventBusController_WaitAsync_Call) Return() *EventBusController_WaitAsync_Call {
	_c.Call.Return()
	return _c
}

func (_c *EventBusController_WaitAsync_Call) RunAndReturn(run func()) *EventBusController_WaitAsync_Call {
	_c.Run(run)
	return _c
}

// NewEventBus creates a new instance of EventBus. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEventBus(t interface {
	mock.TestingT
	Cleanup(func())
}) *EventBus {
	mock := &EventBus{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EventBus is an autogenerated mock type for the Bus type
type EventBus struct {
	mock.Mock
}

type EventBus_Expecter struct {
	mock *mock.Mock
}

func (_m *EventBus) EXPECT() *EventBus_Expecter {
	return &EventBus_Expecter{mock: &_m.Mock}
}

// HasCallback provides a mock function for the type EventBus
func (_mock *EventBus) HasCallback(topic string) bool {
	ret := _mock.Called(topic)

	if len(ret) == 0 {
		panic("no return value specified for HasCallback")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(topic)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// EventBus_HasCallback_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasCallback'
type EventBus_HasCallback_Call struct {
	*mock.Call
}

// HasCallback is a helper method to define mock.On call
//   - topic
func (_e *EventBus_Expecter) HasCallback(topic interface{}) *EventBus_HasCallback_Call {
	return &EventBus_HasCallback_Call{Call: _e.mock.On("HasCallback", topic)}
}

func (_c *EventBus_HasCallback_Call) Run(run func(topic string)) *EventBus_HasCallback_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *EventBus_HasCallback_Call) Return(b bool) *EventBus_HasCallback_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *EventBus_HasCallback_Call) RunAndReturn(run func(topic string) bool) *EventBus_HasCallback_Call {
	_c.Call.Return(run)
	return _c
}

// Publish provides a mock function for the type EventBus
func (_mock *EventBus) Publish(ctx context.Context, topic string, args ...interface{}) {
	if len(args) > 0 {
		_mock.Called(ctx, topic, args)
	} else {
		_mock.Called(ctx, topic)
	}

	return
}

// EventBus_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type EventBus_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - ctx
//   - topic
//   - args
func (_e *EventBus_Expecter) Publish(ctx interface{}, topic interface{}, args ...interface{}) *EventBus_Publish_Call {
	return &EventBus_Publish_Call{Call: _e.mock.On("Publish",
		append([]interface{}{ctx, topic}, args...)...)}
}

func (_c *EventBus_Publish_Call) Run(run func(ctx context.Context, topic string, args ...interface{})) *EventBus_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[2].([]interface{})
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *EventBus_Publish_Call) Return() *EventBus_Publish_Call {
	_c.Call.Return()
	return _c
}

func (_c *EventBus_Publish_Call) RunAndReturn(run func(ctx context.Context, topic string, args ...interface{})) *EventBus_Publish_Call {
	_c.Run(run)
	return _c
}

// Subscribe provides a mock function for the type EventBus
func (_mock *EventBus) Subscribe(topic string, fn interface{}) error {
	ret := _mock.Called(topic, fn)

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = returnFunc(topic, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EventBus_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type EventBus_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - topic
//   - fn
func (_e *EventBus_Expecter) Subscribe(topic interface{}, fn interface{}) *EventBus_Subscribe_Call {
	return &EventBus_Subscribe_Call{Call: _e.mock.On("Subscribe", topic, fn)}
}

func (_c *EventBus_Subscribe_Call) Run(run func(topic string, fn interface{})) *EventBus_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *EventBus_Subscribe_Call) Return(err error) *EventBus_Subscribe_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EventBus_Subscribe_Call) RunAndReturn(run func(topic string, fn interface{}) error) *EventBus_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeAsync provides a mock function for the type EventBus
func (_mock *EventBus) SubscribeAsync(topic string, fn interface{}, transactional bool) error {
	ret := _mock.Called(topic, fn, transactional)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeAsync")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, interface{}, bool) error); ok {
		r0 = returnFunc(topic, fn, transactional)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EventBus_SubscribeAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeAsync'
type EventBus_SubscribeAsync_Call struct {
	*mock.Call
}

// SubscribeAsync is a helper method to define mock.On call
//   - topic
//   - fn
//   - transactional
func (_e *EventBus_Expecter) SubscribeAsync(topic interface{}, fn interface{}, transactional interface{}) *EventBus_SubscribeAsync_Call {
	return &EventBus_SubscribeAsync_Call{Call: _e.mock.On("SubscribeAsync", topic, fn, transactional)}
}

func (_c *EventBus_SubscribeAsync_Call) Run(run func(topic string, fn interface{}, transactional bool)) *EventBus_SubscribeAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}), args[2].(bool))
	})
	return _c
}

func (_c *EventBus_SubscribeAsync_Call) Return(err error) *EventBus_SubscribeAsync_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EventBus_SubscribeAsync_Call) RunAndReturn(run func(topic string, fn interface{}, transactional bool) error) *EventBus_SubscribeAsync_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeOnce provides a mock function for the type EventBus
func (_mock *EventBus) SubscribeOnce(topic string, fn interface{}) error {
	ret := _mock.Called(topic, fn)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeOnce")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = returnFunc(topic, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EventBus_SubscribeOnce_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeOnce'
type EventBus_SubscribeOnce_Call struct {
	*mock.Call
}

// SubscribeOnce is a helper method to define mock.On call
//   - topic
//   - fn
func (_e *EventBus_Expecter) SubscribeOnce(topic interface{}, fn interface{}) *EventBus_SubscribeOnce_Call {
	return &EventBus_SubscribeOnce_Call{Call: _e.mock.On("SubscribeOnce", topic, fn)}
}

func (_c *EventBus_SubscribeOnce_Call) Run(run func(topic string, fn interface{})) *EventBus_SubscribeOnce_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *EventBus_SubscribeOnce_Call) Return(err error) *EventBus_SubscribeOnce_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EventBus_SubscribeOnce_Call) RunAndReturn(run func(topic string, fn interface{}) error) *EventBus_SubscribeOnce_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeOnceAsync provides a mock function for the type EventBus
func (_mock *EventBus) SubscribeOnceAsync(topic string, fn interface{}) error {
	ret := _mock.Called(topic, fn)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeOnceAsync")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = returnFunc(topic, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EventBus_SubscribeOnceAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeOnceAsync'
type EventBus_SubscribeOnceAsync_Call struct {
	*mock.Call
}

// SubscribeOnceAsync is a helper method to define mock.On call
//   - topic
//   - fn
func (_e *EventBus_Expecter) SubscribeOnceAsync(topic interface{}, fn interface{}) *EventBus_SubscribeOnceAsync_Call {
	return &EventBus_SubscribeOnceAsync_Call{Call: _e.mock.On("SubscribeOnceAsync", topic, fn)}
}

func (_c *EventBus_SubscribeOnceAsync_Call) Run(run func(topic string, fn interface{})) *EventBus_SubscribeOnceAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *EventBus_SubscribeOnceAsync_Call) Return(err error) *EventBus_SubscribeOnceAsync_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EventBus_SubscribeOnceAsync_Call) RunAndReturn(run func(topic string, fn interface{}) error) *EventBus_SubscribeOnceAsync_Call {
	_c.Call.Return(run)
	return _c
}

// Unsubscribe provides a mock function for the type EventBus
func (_mock *EventBus) Unsubscribe(topic string, handler interface{}) error {
	ret := _mock.Called(topic, handler)

	if len(ret) == 0 {
		panic("no return value specified for Unsubscribe")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = returnFunc(topic, handler)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EventBus_Unsubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unsubscribe'
type EventBus_Unsubscribe_Call struct {
	*mock.Call
}

// Unsubscribe is a helper method to define mock.On call
//   - topic
//   - handler
func (_e *EventBus_Expecter) Unsubscribe(topic interface{}, handler interface{}) *EventBus_Unsubscribe_Call {
	return &EventBus_Unsubscribe_Call{Call: _e.mock.On("Unsubscribe", topic, handler)}
}

func (_c *EventBus_Unsubscribe_Call) Run(run func(topic string, handler interface{})) *EventBus_Unsubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *EventBus_Unsubscribe_Call) Return(err error) *EventBus_Unsubscribe_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *EventBus_Unsubscribe_Call) RunAndReturn(run func(topic string, handler interface{}) error) *EventBus_Unsubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// WaitAsync provides a mock function for the type EventBus
func (_mock *EventBus) WaitAsync() {
	_mock.Called()
	return
}

// EventBus_WaitAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitAsync'
type EventBus_WaitAsync_Call struct {
	*mock.Call
}

// WaitAsync is a helper method to define mock.On call
func (_e *EventBus_Expecter) WaitAsync() *EventBus_WaitAsync_Call {
	return &EventBus_WaitAsync_Call{Call: _e.mock.On("WaitAsync")}
}

func (_c *EventBus_WaitAsync_Call) Run(run func()) *EventBus_WaitAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EventBus_WaitAsync_Call) Return() *EventBus_WaitAsync_Call {
	_c.Call.Return()
	return _c
}

func (_c *EventBus_WaitAsync_Call) RunAndReturn(run func()) *EventBus_WaitAsync_Call {
	_c.Run(run)
	return _c
}

// NewEventEvent creates a new instance of EventEvent. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEventEvent[T any](t interface {
	mock.TestingT
	Cleanup(func())
}) *EventEvent[T] {
	mock := &EventEvent[T]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// EventEvent is an autogenerated mock type for the Event type
type EventEvent[T any] struct {
	mock.Mock
}

type EventEvent_Expecter[T any] struct {
	mock *mock.Mock
}

func (_m *EventEvent[T]) EXPECT() *EventEvent_Expecter[T] {
	return &EventEvent_Expecter[T]{mock: &_m.Mock}
}

// Execute provides a mock function for the type EventEvent
func (_mock *EventEvent[T]) Execute(ctx context.Context, data T) error {
	ret := _mock.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, T) error); ok {
		r0 = returnFunc(ctx, data)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// EventEvent_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type EventEvent_Execute_Call[T any] struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx
//   - data
func (_e *EventEvent_Expecter[T]) Execute(ctx interface{}, data interface{}) *EventEvent_Execute_Call[T] {
	return &EventEvent_Execute_Call[T]{Call: _e.mock.On("Execute", ctx, data)}
}

func (_c *EventEvent_Execute_Call[T]) Run(run func(ctx context.Context, data T)) *EventEvent_Execute_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(T))
	})
	return _c
}

func (_c *EventEvent_Execute_Call[T]) Return(err error) *EventEvent_Execute_Call[T] {
	_c.Call.Return(err)
	return _c
}

func (_c *EventEvent_Execute_Call[T]) RunAndReturn(run func(ctx context.Context, data T) error) *EventEvent_Execute_Call[T] {
	_c.Call.Return(run)
	return _c
}

// ExecuteAsync provides a mock function for the type EventEvent
func (_mock *EventEvent[T]) ExecuteAsync(ctx context.Context, data T) {
	_mock.Called(ctx, data)
	return
}

// EventEvent_ExecuteAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteAsync'
type EventEvent_ExecuteAsync_Call[T any] struct {
	*mock.Call
}

// ExecuteAsync is a helper method to define mock.On call
//   - ctx
//   - data
func (_e *EventEvent_Expecter[T]) ExecuteAsync(ctx interface{}, data interface{}) *EventEvent_ExecuteAsync_Call[T] {
	return &EventEvent_ExecuteAsync_Call[T]{Call: _e.mock.On("ExecuteAsync", ctx, data)}
}

func (_c *EventEvent_ExecuteAsync_Call[T]) Run(run func(ctx context.Context, data T)) *EventEvent_ExecuteAsync_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(T))
	})
	return _c
}

func (_c *EventEvent_ExecuteAsync_Call[T]) Return() *EventEvent_ExecuteAsync_Call[T] {
	_c.Call.Return()
	return _c
}

func (_c *EventEvent_ExecuteAsync_Call[T]) RunAndReturn(run func(ctx context.Context, data T)) *EventEvent_ExecuteAsync_Call[T] {
	_c.Run(run)
	return _c
}

// Register provides a mock function for the type EventEvent
func (_mock *EventEvent[T]) Register(handler func(ctx context.Context, data T) error) {
	_mock.Called(handler)
	return
}

// EventEvent_Register_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Register'
type EventEvent_Register_Call[T any] struct {
	*mock.Call
}

// Register is a helper method to define mock.On call
//   - handler
func (_e *EventEvent_Expecter[T]) Register(handler interface{}) *EventEvent_Register_Call[T] {
	return &EventEvent_Register_Call[T]{Call: _e.mock.On("Register", handler)}
}

func (_c *EventEvent_Register_Call[T]) Run(run func(handler func(ctx context.Context, data T) error)) *EventEvent_Register_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(func(ctx context.Context, data T) error))
	})
	return _c
}

func (_c *EventEvent_Register_Call[T]) Return() *EventEvent_Register_Call[T] {
	_c.Call.Return()
	return _c
}

func (_c *EventEvent_Register_Call[T]) RunAndReturn(run func(handler func(ctx context.Context, data T) error)) *EventEvent_Register_Call[T] {
	_c.Run(run)
	return _c
}

// Wait provides a mock function for the type EventEvent
func (_mock *EventEvent[T]) Wait() {
	_mock.Called()
	return
}

// EventEvent_Wait_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Wait'
type EventEvent_Wait_Call[T any] struct {
	*mock.Call
}

// Wait is a helper method to define mock.On call
func (_e *EventEvent_Expecter[T]) Wait() *EventEvent_Wait_Call[T] {
	return &EventEvent_Wait_Call[T]{Call: _e.mock.On("Wait")}
}

func (_c *EventEvent_Wait_Call[T]) Run(run func()) *EventEvent_Wait_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *EventEvent_Wait_Call[T]) Return() *EventEvent_Wait_Call[T] {
	_c.Call.Return()
	return _c
}

func (_c *EventEvent_Wait_Call[T]) RunAndReturn(run func()) *EventEvent_Wait_Call[T] {
	_c.Run(run)
	return _c
}
