// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"time"

	"github.com/mikhailbolshakov/kit/kafka"
	mock "github.com/stretchr/testify/mock"
)

// NewKafkaBroker creates a new instance of KafkaBroker. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKafkaBroker(t interface {
	mock.TestingT
	Cleanup(func())
}) *KafkaBroker {
	mock := &KafkaBroker{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KafkaBroker is an autogenerated mock type for the Broker type
type KafkaBroker struct {
	mock.Mock
}

type KafkaBroker_Expecter struct {
	mock *mock.Mock
}

func (_m *KafkaBroker) EXPECT() *KafkaBroker_Expecter {
	return &KafkaBroker_Expecter{mock: &_m.Mock}
}

// AddProducer provides a mock function for the type KafkaBroker
func (_mock *KafkaBroker) AddProducer(ctx context.Context, topic *kafka.TopicConfig, cfg *kafka.ProducerConfig) (kafka.Producer, error) {
	ret := _mock.Called(ctx, topic, cfg)

	if len(ret) == 0 {
		panic("no return value specified for AddProducer")
	}

	var r0 kafka.Producer
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *kafka.TopicConfig, *kafka.ProducerConfig) (kafka.Producer, error)); ok {
		return returnFunc(ctx, topic, cfg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *kafka.TopicConfig, *kafka.ProducerConfig) kafka.Producer); ok {
		r0 = returnFunc(ctx, topic, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.Producer)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *kafka.TopicConfig, *kafka.ProducerConfig) error); ok {
		r1 = returnFunc(ctx, topic, cfg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// KafkaBroker_AddProducer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddProducer'
type KafkaBroker_AddProducer_Call struct {
	*mock.Call
}

// AddProducer is a helper method to define mock.On call
//   - ctx
//   - topic
//   - cfg
func (_e *KafkaBroker_Expecter) AddProducer(ctx interface{}, topic interface{}, cfg interface{}) *KafkaBroker_AddProducer_Call {
	return &KafkaBroker_AddProducer_Call{Call: _e.mock.On("AddProducer", ctx, topic, cfg)}
}

func (_c *KafkaBroker_AddProducer_Call) Run(run func(ctx context.Context, topic *kafka.TopicConfig, cfg *kafka.ProducerConfig)) *KafkaBroker_AddProducer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*kafka.TopicConfig), args[2].(*kafka.ProducerConfig))
	})
	return _c
}

func (_c *KafkaBroker_AddProducer_Call) Return(producer kafka.Producer, err error) *KafkaBroker_AddProducer_Call {
	_c.Call.Return(producer, err)
	return _c
}

func (_c *KafkaBroker_AddProducer_Call) RunAndReturn(run func(ctx context.Context, topic *kafka.TopicConfig, cfg *kafka.ProducerConfig) (kafka.Producer, error)) *KafkaBroker_AddProducer_Call {
	_c.Call.Return(run)
	return _c
}

// AddSubscriber provides a mock function for the type KafkaBroker
func (_mock *KafkaBroker) AddSubscriber(ctx context.Context, topic *kafka.TopicConfig, cfg *kafka.SubscriberConfig, handlers ...kafka.HandlerFn) error {
	var tmpRet mock.Arguments
	if len(handlers) > 0 {
		tmpRet = _mock.Called(ctx, topic, cfg, handlers)
	} else {
		tmpRet = _mock.Called(ctx, topic, cfg)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for AddSubscriber")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *kafka.TopicConfig, *kafka.SubscriberConfig, ...kafka.HandlerFn) error); ok {
		r0 = returnFunc(ctx, topic, cfg, handlers...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KafkaBroker_AddSubscriber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddSubscriber'
type KafkaBroker_AddSubscriber_Call struct {
	*mock.Call
}

// AddSubscriber is a helper method to define mock.On call
//   - ctx
//   - topic
//   - cfg
//   - handlers
func (_e *KafkaBroker_Expecter) AddSubscriber(ctx interface{}, topic interface{}, cfg interface{}, handlers ...interface{}) *KafkaBroker_AddSubscriber_Call {
	return &KafkaBroker_AddSubscriber_Call{Call: _e.mock.On("AddSubscriber",
		append([]interface{}{ctx, topic, cfg}, handlers...)...)}
}

func (_c *KafkaBroker_AddSubscriber_Call) Run(run func(ctx context.Context, topic *kafka.TopicConfig, cfg *kafka.SubscriberConfig, handlers ...kafka.HandlerFn)) *KafkaBroker_AddSubscriber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[3].([]kafka.HandlerFn)
		run(args[0].(context.Context), args[1].(*kafka.TopicConfig), args[2].(*kafka.SubscriberConfig), variadicArgs...)
	})
	return _c
}

func (_c *KafkaBroker_AddSubscriber_Call) Return(err error) *KafkaBroker_AddSubscriber_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *KafkaBroker_AddSubscriber_Call) RunAndReturn(run func(ctx context.Context, topic *kafka.TopicConfig, cfg *kafka.SubscriberConfig, handlers ...kafka.HandlerFn) error) *KafkaBroker_AddSubscriber_Call {
	_c.Call.Return(run)
	return _c
}

// Close provides a mock function for the type KafkaBroker
func (_mock *KafkaBroker) Close(ctx context.Context) {
	_mock.Called(ctx)
	return
}

// KafkaBroker_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type KafkaBroker_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
//   - ctx
func (_e *KafkaBroker_Expecter) Close(ctx interface{}) *KafkaBroker_Close_Call {
	return &KafkaBroker_Close_Call{Call: _e.mock.On("Close", ctx)}
}

func (_c *KafkaBroker_Close_Call) Run(run func(ctx context.Context)) *KafkaBroker_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *KafkaBroker_Close_Call) Return() *KafkaBroker_Close_Call {
	_c.Call.Return()
	return _c
}

func (_c *KafkaBroker_Close_Call) RunAndReturn(run func(ctx context.Context)) *KafkaBroker_Close_Call {
	_c.Run(run)
	return _c
}

// DeclareTopics provides a mock function for the type KafkaBroker
func (_mock *KafkaBroker) DeclareTopics(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for DeclareTopics")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KafkaBroker_DeclareTopics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeclareTopics'
type KafkaBroker_DeclareTopics_Call struct {
	*mock.Call
}

// DeclareTopics is a helper method to define mock.On call
//   - ctx
func (_e *KafkaBroker_Expecter) DeclareTopics(ctx interface{}) *KafkaBroker_DeclareTopics_Call {
	return &KafkaBroker_DeclareTopics_Call{Call: _e.mock.On("DeclareTopics", ctx)}
}

func (_c *KafkaBroker_DeclareTopics_Call) Run(run func(ctx context.Context)) *KafkaBroker_DeclareTopics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *KafkaBroker_DeclareTopics_Call) Return(err error) *KafkaBroker_DeclareTopics_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *KafkaBroker_DeclareTopics_Call) RunAndReturn(run func(ctx context.Context) error) *KafkaBroker_DeclareTopics_Call {
	_c.Call.Return(run)
	return _c
}

// Init provides a mock function for the type KafkaBroker
func (_mock *KafkaBroker) Init(ctx context.Context, cfg *kafka.BrokerConfig) error {
	ret := _mock.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for Init")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *kafka.BrokerConfig) error); ok {
		r0 = returnFunc(ctx, cfg)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KafkaBroker_Init_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Init'
type KafkaBroker_Init_Call struct {
	*mock.Call
}

// Init is a helper method to define mock.On call
//   - ctx
//   - cfg
func (_e *KafkaBroker_Expecter) Init(ctx interface{}, cfg interface{}) *KafkaBroker_Init_Call {
	return &KafkaBroker_Init_Call{Call: _e.mock.On("Init", ctx, cfg)}
}

func (_c *KafkaBroker_Init_Call) Run(run func(ctx context.Context, cfg *kafka.BrokerConfig)) *KafkaBroker_Init_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*kafka.BrokerConfig))
	})
	return _c
}

func (_c *KafkaBroker_Init_Call) Return(err error) *KafkaBroker_Init_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *KafkaBroker_Init_Call) RunAndReturn(run func(ctx context.Context, cfg *kafka.BrokerConfig) error) *KafkaBroker_Init_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type KafkaBroker
func (_mock *KafkaBroker) Start(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KafkaBroker_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type KafkaBroker_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - ctx
func (_e *KafkaBroker_Expecter) Start(ctx interface{}) *KafkaBroker_Start_Call {
	return &KafkaBroker_Start_Call{Call: _e.mock.On("Start", ctx)}
}

func (_c *KafkaBroker_Start_Call) Run(run func(ctx context.Context)) *KafkaBroker_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *KafkaBroker_Start_Call) Return(err error) *KafkaBroker_Start_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *KafkaBroker_Start_Call) RunAndReturn(run func(ctx context.Context) error) *KafkaBroker_Start_Call {
	_c.Call.Return(run)
	return _c
}

// NewKafkaProducer creates a new instance of KafkaProducer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKafkaProducer(t interface {
	mock.TestingT
	Cleanup(func())
}) *KafkaProducer {
	mock := &KafkaProducer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KafkaProducer is an autogenerated mock type for the Producer type
type KafkaProducer struct {
	mock.Mock
}

type KafkaProducer_Expecter struct {
	mock *mock.Mock
}

func (_m *KafkaProducer) EXPECT() *KafkaProducer_Expecter {
	return &KafkaProducer_Expecter{mock: &_m.Mock}
}

// Send provides a mock function for the type KafkaProducer
func (_mock *KafkaProducer) Send(ctx context.Context, key string, payload interface{}) error {
	ret := _mock.Called(ctx, key, payload)

	if len(ret) == 0 {
		panic("no return value specified for Send")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, interface{}) error); ok {
		r0 = returnFunc(ctx, key, payload)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KafkaProducer_Send_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Send'
type KafkaProducer_Send_Call struct {
	*mock.Call
}

// Send is a helper method to define mock.On call
//   - ctx
//   - key
//   - payload
func (_e *KafkaProducer_Expecter) Send(ctx interface{}, key interface{}, payload interface{}) *KafkaProducer_Send_Call {
	return &KafkaProducer_Send_Call{Call: _e.mock.On("Send", ctx, key, payload)}
}

func (_c *KafkaProducer_Send_Call) Run(run func(ctx context.Context, key string, payload interface{})) *KafkaProducer_Send_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *KafkaProducer_Send_Call) Return(err error) *KafkaProducer_Send_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *KafkaProducer_Send_Call) RunAndReturn(run func(ctx context.Context, key string, payload interface{}) error) *KafkaProducer_Send_Call {
	_c.Call.Return(run)
	return _c
}

// SendMany provides a mock function for the type KafkaProducer
func (_mock *KafkaProducer) SendMany(ctx context.Context, messages ...*kafka.Message) error {
	var tmpRet mock.Arguments
	if len(messages) > 0 {
		tmpRet = _mock.Called(ctx, messages)
	} else {
		tmpRet = _mock.Called(ctx)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for SendMany")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...*kafka.Message) error); ok {
		r0 = returnFunc(ctx, messages...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KafkaProducer_SendMany_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendMany'
type KafkaProducer_SendMany_Call struct {
	*mock.Call
}

// SendMany is a helper method to define mock.On call
//   - ctx
//   - messages
func (_e *KafkaProducer_Expecter) SendMany(ctx interface{}, messages ...interface{}) *KafkaProducer_SendMany_Call {
	return &KafkaProducer_SendMany_Call{Call: _e.mock.On("SendMany",
		append([]interface{}{ctx}, messages...)...)}
}

func (_c *KafkaProducer_SendMany_Call) Run(run func(ctx context.Context, messages ...*kafka.Message)) *KafkaProducer_SendMany_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[1].([]*kafka.Message)
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *KafkaProducer_SendMany_Call) Return(err error) *KafkaProducer_SendMany_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *KafkaProducer_SendMany_Call) RunAndReturn(run func(ctx context.Context, messages ...*kafka.Message) error) *KafkaProducer_SendMany_Call {
	_c.Call.Return(run)
	return _c
}

// NewKafkaProducerConfigBuilder creates a new instance of KafkaProducerConfigBuilder. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKafkaProducerConfigBuilder(t interface {
	mock.TestingT
	Cleanup(func())
}) *KafkaProducerConfigBuilder {
	mock := &KafkaProducerConfigBuilder{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KafkaProducerConfigBuilder is an autogenerated mock type for the ProducerConfigBuilder type
type KafkaProducerConfigBuilder struct {
	mock.Mock
}

type KafkaProducerConfigBuilder_Expecter struct {
	mock *mock.Mock
}

func (_m *KafkaProducerConfigBuilder) EXPECT() *KafkaProducerConfigBuilder_Expecter {
	return &KafkaProducerConfigBuilder_Expecter{mock: &_m.Mock}
}

// Async provides a mock function for the type KafkaProducerConfigBuilder
func (_mock *KafkaProducerConfigBuilder) Async(v bool) kafka.ProducerConfigBuilder {
	ret := _mock.Called(v)

	if len(ret) == 0 {
		panic("no return value specified for Async")
	}

	var r0 kafka.ProducerConfigBuilder
	if returnFunc, ok := ret.Get(0).(func(bool) kafka.ProducerConfigBuilder); ok {
		r0 = returnFunc(v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.ProducerConfigBuilder)
		}
	}
	return r0
}

// KafkaProducerConfigBuilder_Async_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Async'
type KafkaProducerConfigBuilder_Async_Call struct {
	*mock.Call
}

// Async is a helper method to define mock.On call
//   - v
func (_e *KafkaProducerConfigBuilder_Expecter) Async(v interface{}) *KafkaProducerConfigBuilder_Async_Call {
	return &KafkaProducerConfigBuilder_Async_Call{Call: _e.mock.On("Async", v)}
}

func (_c *KafkaProducerConfigBuilder_Async_Call) Run(run func(v bool)) *KafkaProducerConfigBuilder_Async_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *KafkaProducerConfigBuilder_Async_Call) Return(producerConfigBuilder kafka.ProducerConfigBuilder) *KafkaProducerConfigBuilder_Async_Call {
	_c.Call.Return(producerConfigBuilder)
	return _c
}

func (_c *KafkaProducerConfigBuilder_Async_Call) RunAndReturn(run func(v bool) kafka.ProducerConfigBuilder) *KafkaProducerConfigBuilder_Async_Call {
	_c.Call.Return(run)
	return _c
}

// BatchSize provides a mock function for the type KafkaProducerConfigBuilder
func (_mock *KafkaProducerConfigBuilder) BatchSize(size int) kafka.ProducerConfigBuilder {
	ret := _mock.Called(size)

	if len(ret) == 0 {
		panic("no return value specified for BatchSize")
	}

	var r0 kafka.ProducerConfigBuilder
	if returnFunc, ok := ret.Get(0).(func(int) kafka.ProducerConfigBuilder); ok {
		r0 = returnFunc(size)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.ProducerConfigBuilder)
		}
	}
	return r0
}

// KafkaProducerConfigBuilder_BatchSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchSize'
type KafkaProducerConfigBuilder_BatchSize_Call struct {
	*mock.Call
}

// BatchSize is a helper method to define mock.On call
//   - size
func (_e *KafkaProducerConfigBuilder_Expecter) BatchSize(size interface{}) *KafkaProducerConfigBuilder_BatchSize_Call {
	return &KafkaProducerConfigBuilder_BatchSize_Call{Call: _e.mock.On("BatchSize", size)}
}

func (_c *KafkaProducerConfigBuilder_BatchSize_Call) Run(run func(size int)) *KafkaProducerConfigBuilder_BatchSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *KafkaProducerConfigBuilder_BatchSize_Call) Return(producerConfigBuilder kafka.ProducerConfigBuilder) *KafkaProducerConfigBuilder_BatchSize_Call {
	_c.Call.Return(producerConfigBuilder)
	return _c
}

func (_c *KafkaProducerConfigBuilder_BatchSize_Call) RunAndReturn(run func(size int) kafka.ProducerConfigBuilder) *KafkaProducerConfigBuilder_BatchSize_Call {
	_c.Call.Return(run)
	return _c
}

// BatchTimeout provides a mock function for the type KafkaProducerConfigBuilder
func (_mock *KafkaProducerConfigBuilder) BatchTimeout(to time.Duration) kafka.ProducerConfigBuilder {
	ret := _mock.Called(to)

	if len(ret) == 0 {
		panic("no return value specified for BatchTimeout")
	}

	var r0 kafka.ProducerConfigBuilder
	if returnFunc, ok := ret.Get(0).(func(time.Duration) kafka.ProducerConfigBuilder); ok {
		r0 = returnFunc(to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.ProducerConfigBuilder)
		}
	}
	return r0
}

// KafkaProducerConfigBuilder_BatchTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchTimeout'
type KafkaProducerConfigBuilder_BatchTimeout_Call struct {
	*mock.Call
}

// BatchTimeout is a helper method to define mock.On call
//   - to
func (_e *KafkaProducerConfigBuilder_Expecter) BatchTimeout(to interface{}) *KafkaProducerConfigBuilder_BatchTimeout_Call {
	return &KafkaProducerConfigBuilder_BatchTimeout_Call{Call: _e.mock.On("BatchTimeout", to)}
}

func (_c *KafkaProducerConfigBuilder_BatchTimeout_Call) Run(run func(to time.Duration)) *KafkaProducerConfigBuilder_BatchTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Duration))
	})
	return _c
}

func (_c *KafkaProducerConfigBuilder_BatchTimeout_Call) Return(producerConfigBuilder kafka.ProducerConfigBuilder) *KafkaProducerConfigBuilder_BatchTimeout_Call {
	_c.Call.Return(producerConfigBuilder)
	return _c
}

func (_c *KafkaProducerConfigBuilder_BatchTimeout_Call) RunAndReturn(run func(to time.Duration) kafka.ProducerConfigBuilder) *KafkaProducerConfigBuilder_BatchTimeout_Call {
	_c.Call.Return(run)
	return _c
}

// Build provides a mock function for the type KafkaProducerConfigBuilder
func (_mock *KafkaProducerConfigBuilder) Build() *kafka.ProducerConfig {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Build")
	}

	var r0 *kafka.ProducerConfig
	if returnFunc, ok := ret.Get(0).(func() *kafka.ProducerConfig); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.ProducerConfig)
		}
	}
	return r0
}

// KafkaProducerConfigBuilder_Build_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Build'
type KafkaProducerConfigBuilder_Build_Call struct {
	*mock.Call
}

// Build is a helper method to define mock.On call
func (_e *KafkaProducerConfigBuilder_Expecter) Build() *KafkaProducerConfigBuilder_Build_Call {
	return &KafkaProducerConfigBuilder_Build_Call{Call: _e.mock.On("Build")}
}

func (_c *KafkaProducerConfigBuilder_Build_Call) Run(run func()) *KafkaProducerConfigBuilder_Build_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KafkaProducerConfigBuilder_Build_Call) Return(producerConfig *kafka.ProducerConfig) *KafkaProducerConfigBuilder_Build_Call {
	_c.Call.Return(producerConfig)
	return _c
}

func (_c *KafkaProducerConfigBuilder_Build_Call) RunAndReturn(run func() *kafka.ProducerConfig) *KafkaProducerConfigBuilder_Build_Call {
	_c.Call.Return(run)
	return _c
}

// RequiredAcks provides a mock function for the type KafkaProducerConfigBuilder
func (_mock *KafkaProducerConfigBuilder) RequiredAcks(v int) kafka.ProducerConfigBuilder {
	ret := _mock.Called(v)

	if len(ret) == 0 {
		panic("no return value specified for RequiredAcks")
	}

	var r0 kafka.ProducerConfigBuilder
	if returnFunc, ok := ret.Get(0).(func(int) kafka.ProducerConfigBuilder); ok {
		r0 = returnFunc(v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.ProducerConfigBuilder)
		}
	}
	return r0
}

// KafkaProducerConfigBuilder_RequiredAcks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RequiredAcks'
type KafkaProducerConfigBuilder_RequiredAcks_Call struct {
	*mock.Call
}

// RequiredAcks is a helper method to define mock.On call
//   - v
func (_e *KafkaProducerConfigBuilder_Expecter) RequiredAcks(v interface{}) *KafkaProducerConfigBuilder_RequiredAcks_Call {
	return &KafkaProducerConfigBuilder_RequiredAcks_Call{Call: _e.mock.On("RequiredAcks", v)}
}

func (_c *KafkaProducerConfigBuilder_RequiredAcks_Call) Run(run func(v int)) *KafkaProducerConfigBuilder_RequiredAcks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *KafkaProducerConfigBuilder_RequiredAcks_Call) Return(producerConfigBuilder kafka.ProducerConfigBuilder) *KafkaProducerConfigBuilder_RequiredAcks_Call {
	_c.Call.Return(producerConfigBuilder)
	return _c
}

func (_c *KafkaProducerConfigBuilder_RequiredAcks_Call) RunAndReturn(run func(v int) kafka.ProducerConfigBuilder) *KafkaProducerConfigBuilder_RequiredAcks_Call {
	_c.Call.Return(run)
	return _c
}

// Retry provides a mock function for the type KafkaProducerConfigBuilder
func (_mock *KafkaProducerConfigBuilder) Retry(time1 int, timeout time.Duration) kafka.ProducerConfigBuilder {
	ret := _mock.Called(time1, timeout)

	if len(ret) == 0 {
		panic("no return value specified for Retry")
	}

	var r0 kafka.ProducerConfigBuilder
	if returnFunc, ok := ret.Get(0).(func(int, time.Duration) kafka.ProducerConfigBuilder); ok {
		r0 = returnFunc(time1, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.ProducerConfigBuilder)
		}
	}
	return r0
}

// KafkaProducerConfigBuilder_Retry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Retry'
type KafkaProducerConfigBuilder_Retry_Call struct {
	*mock.Call
}

// Retry is a helper method to define mock.On call
//   - time1
//   - timeout
func (_e *KafkaProducerConfigBuilder_Expecter) Retry(time1 interface{}, timeout interface{}) *KafkaProducerConfigBuilder_Retry_Call {
	return &KafkaProducerConfigBuilder_Retry_Call{Call: _e.mock.On("Retry", time1, timeout)}
}

func (_c *KafkaProducerConfigBuilder_Retry_Call) Run(run func(time1 int, timeout time.Duration)) *KafkaProducerConfigBuilder_Retry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(time.Duration))
	})
	return _c
}

func (_c *KafkaProducerConfigBuilder_Retry_Call) Return(producerConfigBuilder kafka.ProducerConfigBuilder) *KafkaProducerConfigBuilder_Retry_Call {
	_c.Call.Return(producerConfigBuilder)
	return _c
}

func (_c *KafkaProducerConfigBuilder_Retry_Call) RunAndReturn(run func(time1 int, timeout time.Duration) kafka.ProducerConfigBuilder) *KafkaProducerConfigBuilder_Retry_Call {
	_c.Call.Return(run)
	return _c
}

// NewKafkasubscriberStrategy creates a new instance of KafkasubscriberStrategy. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKafkasubscriberStrategy(t interface {
	mock.TestingT
	Cleanup(func())
}) *KafkasubscriberStrategy {
	mock := &KafkasubscriberStrategy{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KafkasubscriberStrategy is an autogenerated mock type for the subscriberStrategy type
type KafkasubscriberStrategy struct {
	mock.Mock
}

type KafkasubscriberStrategy_Expecter struct {
	mock *mock.Mock
}

func (_m *KafkasubscriberStrategy) EXPECT() *KafkasubscriberStrategy_Expecter {
	return &KafkasubscriberStrategy_Expecter{mock: &_m.Mock}
}

// start provides a mock function for the type KafkasubscriberStrategy
func (_mock *KafkasubscriberStrategy) start(ctx context.Context, topic string) {
	_mock.Called(ctx, topic)
	return
}

// KafkasubscriberStrategy_start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'start'
type KafkasubscriberStrategy_start_Call struct {
	*mock.Call
}

// start is a helper method to define mock.On call
//   - ctx
//   - topic
func (_e *KafkasubscriberStrategy_Expecter) start(ctx interface{}, topic interface{}) *KafkasubscriberStrategy_start_Call {
	return &KafkasubscriberStrategy_start_Call{Call: _e.mock.On("start", ctx, topic)}
}

func (_c *KafkasubscriberStrategy_start_Call) Run(run func(ctx context.Context, topic string)) *KafkasubscriberStrategy_start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *KafkasubscriberStrategy_start_Call) Return() *KafkasubscriberStrategy_start_Call {
	_c.Call.Return()
	return _c
}

func (_c *KafkasubscriberStrategy_start_Call) RunAndReturn(run func(ctx context.Context, topic string)) *KafkasubscriberStrategy_start_Call {
	_c.Run(run)
	return _c
}

// NewKafkaSubscriberConfigBuilder creates a new instance of KafkaSubscriberConfigBuilder. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKafkaSubscriberConfigBuilder(t interface {
	mock.TestingT
	Cleanup(func())
}) *KafkaSubscriberConfigBuilder {
	mock := &KafkaSubscriberConfigBuilder{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KafkaSubscriberConfigBuilder is an autogenerated mock type for the SubscriberConfigBuilder type
type KafkaSubscriberConfigBuilder struct {
	mock.Mock
}

type KafkaSubscriberConfigBuilder_Expecter struct {
	mock *mock.Mock
}

func (_m *KafkaSubscriberConfigBuilder) EXPECT() *KafkaSubscriberConfigBuilder_Expecter {
	return &KafkaSubscriberConfigBuilder_Expecter{mock: &_m.Mock}
}

// BatchTimeout provides a mock function for the type KafkaSubscriberConfigBuilder
func (_mock *KafkaSubscriberConfigBuilder) BatchTimeout(to time.Duration) kafka.SubscriberConfigBuilder {
	ret := _mock.Called(to)

	if len(ret) == 0 {
		panic("no return value specified for BatchTimeout")
	}

	var r0 kafka.SubscriberConfigBuilder
	if returnFunc, ok := ret.Get(0).(func(time.Duration) kafka.SubscriberConfigBuilder); ok {
		r0 = returnFunc(to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.SubscriberConfigBuilder)
		}
	}
	return r0
}

// KafkaSubscriberConfigBuilder_BatchTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchTimeout'
type KafkaSubscriberConfigBuilder_BatchTimeout_Call struct {
	*mock.Call
}

// BatchTimeout is a helper method to define mock.On call
//   - to
func (_e *KafkaSubscriberConfigBuilder_Expecter) BatchTimeout(to interface{}) *KafkaSubscriberConfigBuilder_BatchTimeout_Call {
	return &KafkaSubscriberConfigBuilder_BatchTimeout_Call{Call: _e.mock.On("BatchTimeout", to)}
}

func (_c *KafkaSubscriberConfigBuilder_BatchTimeout_Call) Run(run func(to time.Duration)) *KafkaSubscriberConfigBuilder_BatchTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Duration))
	})
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_BatchTimeout_Call) Return(subscriberConfigBuilder kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_BatchTimeout_Call {
	_c.Call.Return(subscriberConfigBuilder)
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_BatchTimeout_Call) RunAndReturn(run func(to time.Duration) kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_BatchTimeout_Call {
	_c.Call.Return(run)
	return _c
}

// Build provides a mock function for the type KafkaSubscriberConfigBuilder
func (_mock *KafkaSubscriberConfigBuilder) Build() *kafka.SubscriberConfig {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Build")
	}

	var r0 *kafka.SubscriberConfig
	if returnFunc, ok := ret.Get(0).(func() *kafka.SubscriberConfig); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.SubscriberConfig)
		}
	}
	return r0
}

// KafkaSubscriberConfigBuilder_Build_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Build'
type KafkaSubscriberConfigBuilder_Build_Call struct {
	*mock.Call
}

// Build is a helper method to define mock.On call
func (_e *KafkaSubscriberConfigBuilder_Expecter) Build() *KafkaSubscriberConfigBuilder_Build_Call {
	return &KafkaSubscriberConfigBuilder_Build_Call{Call: _e.mock.On("Build")}
}

func (_c *KafkaSubscriberConfigBuilder_Build_Call) Run(run func()) *KafkaSubscriberConfigBuilder_Build_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_Build_Call) Return(subscriberConfig *kafka.SubscriberConfig) *KafkaSubscriberConfigBuilder_Build_Call {
	_c.Call.Return(subscriberConfig)
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_Build_Call) RunAndReturn(run func() *kafka.SubscriberConfig) *KafkaSubscriberConfigBuilder_Build_Call {
	_c.Call.Return(run)
	return _c
}

// CommitInterval provides a mock function for the type KafkaSubscriberConfigBuilder
func (_mock *KafkaSubscriberConfigBuilder) CommitInterval(to time.Duration) kafka.SubscriberConfigBuilder {
	ret := _mock.Called(to)

	if len(ret) == 0 {
		panic("no return value specified for CommitInterval")
	}

	var r0 kafka.SubscriberConfigBuilder
	if returnFunc, ok := ret.Get(0).(func(time.Duration) kafka.SubscriberConfigBuilder); ok {
		r0 = returnFunc(to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.SubscriberConfigBuilder)
		}
	}
	return r0
}

// KafkaSubscriberConfigBuilder_CommitInterval_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommitInterval'
type KafkaSubscriberConfigBuilder_CommitInterval_Call struct {
	*mock.Call
}

// CommitInterval is a helper method to define mock.On call
//   - to
func (_e *KafkaSubscriberConfigBuilder_Expecter) CommitInterval(to interface{}) *KafkaSubscriberConfigBuilder_CommitInterval_Call {
	return &KafkaSubscriberConfigBuilder_CommitInterval_Call{Call: _e.mock.On("CommitInterval", to)}
}

func (_c *KafkaSubscriberConfigBuilder_CommitInterval_Call) Run(run func(to time.Duration)) *KafkaSubscriberConfigBuilder_CommitInterval_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Duration))
	})
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_CommitInterval_Call) Return(subscriberConfigBuilder kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_CommitInterval_Call {
	_c.Call.Return(subscriberConfigBuilder)
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_CommitInterval_Call) RunAndReturn(run func(to time.Duration) kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_CommitInterval_Call {
	_c.Call.Return(run)
	return _c
}

// DLQProducer provides a mock function for the type KafkaSubscriberConfigBuilder
func (_mock *KafkaSubscriberConfigBuilder) DLQProducer(p kafka.Producer) kafka.SubscriberConfigBuilder {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for DLQProducer")
	}

	var r0 kafka.SubscriberConfigBuilder
	if returnFunc, ok := ret.Get(0).(func(kafka.Producer) kafka.SubscriberConfigBuilder); ok {
		r0 = returnFunc(p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.SubscriberConfigBuilder)
		}
	}
	return r0
}

// KafkaSubscriberConfigBuilder_DLQProducer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DLQProducer'
type KafkaSubscriberConfigBuilder_DLQProducer_Call struct {
	*mock.Call
}

// DLQProducer is a helper method to define mock.On call
//   - p
func (_e *KafkaSubscriberConfigBuilder_Expecter) DLQProducer(p interface{}) *KafkaSubscriberConfigBuilder_DLQProducer_Call {
	return &KafkaSubscriberConfigBuilder_DLQProducer_Call{Call: _e.mock.On("DLQProducer", p)}
}

func (_c *KafkaSubscriberConfigBuilder_DLQProducer_Call) Run(run func(p kafka.Producer)) *KafkaSubscriberConfigBuilder_DLQProducer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(kafka.Producer))
	})
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_DLQProducer_Call) Return(subscriberConfigBuilder kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_DLQProducer_Call {
	_c.Call.Return(subscriberConfigBuilder)
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_DLQProducer_Call) RunAndReturn(run func(p kafka.Producer) kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_DLQProducer_Call {
	_c.Call.Return(run)
	return _c
}

// GroupId provides a mock function for the type KafkaSubscriberConfigBuilder
func (_mock *KafkaSubscriberConfigBuilder) GroupId(groupId string) kafka.SubscriberConfigBuilder {
	ret := _mock.Called(groupId)

	if len(ret) == 0 {
		panic("no return value specified for GroupId")
	}

	var r0 kafka.SubscriberConfigBuilder
	if returnFunc, ok := ret.Get(0).(func(string) kafka.SubscriberConfigBuilder); ok {
		r0 = returnFunc(groupId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.SubscriberConfigBuilder)
		}
	}
	return r0
}

// KafkaSubscriberConfigBuilder_GroupId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupId'
type KafkaSubscriberConfigBuilder_GroupId_Call struct {
	*mock.Call
}

// GroupId is a helper method to define mock.On call
//   - groupId
func (_e *KafkaSubscriberConfigBuilder_Expecter) GroupId(groupId interface{}) *KafkaSubscriberConfigBuilder_GroupId_Call {
	return &KafkaSubscriberConfigBuilder_GroupId_Call{Call: _e.mock.On("GroupId", groupId)}
}

func (_c *KafkaSubscriberConfigBuilder_GroupId_Call) Run(run func(groupId string)) *KafkaSubscriberConfigBuilder_GroupId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_GroupId_Call) Return(subscriberConfigBuilder kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_GroupId_Call {
	_c.Call.Return(subscriberConfigBuilder)
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_GroupId_Call) RunAndReturn(run func(groupId string) kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_GroupId_Call {
	_c.Call.Return(run)
	return _c
}

// JoinGroupBackoff provides a mock function for the type KafkaSubscriberConfigBuilder
func (_mock *KafkaSubscriberConfigBuilder) JoinGroupBackoff(t time.Duration) kafka.SubscriberConfigBuilder {
	ret := _mock.Called(t)

	if len(ret) == 0 {
		panic("no return value specified for JoinGroupBackoff")
	}

	var r0 kafka.SubscriberConfigBuilder
	if returnFunc, ok := ret.Get(0).(func(time.Duration) kafka.SubscriberConfigBuilder); ok {
		r0 = returnFunc(t)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.SubscriberConfigBuilder)
		}
	}
	return r0
}

// KafkaSubscriberConfigBuilder_JoinGroupBackoff_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JoinGroupBackoff'
type KafkaSubscriberConfigBuilder_JoinGroupBackoff_Call struct {
	*mock.Call
}

// JoinGroupBackoff is a helper method to define mock.On call
//   - t
func (_e *KafkaSubscriberConfigBuilder_Expecter) JoinGroupBackoff(t interface{}) *KafkaSubscriberConfigBuilder_JoinGroupBackoff_Call {
	return &KafkaSubscriberConfigBuilder_JoinGroupBackoff_Call{Call: _e.mock.On("JoinGroupBackoff", t)}
}

func (_c *KafkaSubscriberConfigBuilder_JoinGroupBackoff_Call) Run(run func(t time.Duration)) *KafkaSubscriberConfigBuilder_JoinGroupBackoff_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Duration))
	})
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_JoinGroupBackoff_Call) Return(subscriberConfigBuilder kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_JoinGroupBackoff_Call {
	_c.Call.Return(subscriberConfigBuilder)
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_JoinGroupBackoff_Call) RunAndReturn(run func(t time.Duration) kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_JoinGroupBackoff_Call {
	_c.Call.Return(run)
	return _c
}

// Logging provides a mock function for the type KafkaSubscriberConfigBuilder
func (_mock *KafkaSubscriberConfigBuilder) Logging(v bool) kafka.SubscriberConfigBuilder {
	ret := _mock.Called(v)

	if len(ret) == 0 {
		panic("no return value specified for Logging")
	}

	var r0 kafka.SubscriberConfigBuilder
	if returnFunc, ok := ret.Get(0).(func(bool) kafka.SubscriberConfigBuilder); ok {
		r0 = returnFunc(v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.SubscriberConfigBuilder)
		}
	}
	return r0
}

// KafkaSubscriberConfigBuilder_Logging_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Logging'
type KafkaSubscriberConfigBuilder_Logging_Call struct {
	*mock.Call
}

// Logging is a helper method to define mock.On call
//   - v
func (_e *KafkaSubscriberConfigBuilder_Expecter) Logging(v interface{}) *KafkaSubscriberConfigBuilder_Logging_Call {
	return &KafkaSubscriberConfigBuilder_Logging_Call{Call: _e.mock.On("Logging", v)}
}

func (_c *KafkaSubscriberConfigBuilder_Logging_Call) Run(run func(v bool)) *KafkaSubscriberConfigBuilder_Logging_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_Logging_Call) Return(subscriberConfigBuilder kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_Logging_Call {
	_c.Call.Return(subscriberConfigBuilder)
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_Logging_Call) RunAndReturn(run func(v bool) kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_Logging_Call {
	_c.Call.Return(run)
	return _c
}

// ManualCommitHandleMessageMaxRetryCount provides a mock function for the type KafkaSubscriberConfigBuilder
func (_mock *KafkaSubscriberConfigBuilder) ManualCommitHandleMessageMaxRetryCount(v int) kafka.SubscriberConfigBuilder {
	ret := _mock.Called(v)

	if len(ret) == 0 {
		panic("no return value specified for ManualCommitHandleMessageMaxRetryCount")
	}

	var r0 kafka.SubscriberConfigBuilder
	if returnFunc, ok := ret.Get(0).(func(int) kafka.SubscriberConfigBuilder); ok {
		r0 = returnFunc(v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.SubscriberConfigBuilder)
		}
	}
	return r0
}

// KafkaSubscriberConfigBuilder_ManualCommitHandleMessageMaxRetryCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ManualCommitHandleMessageMaxRetryCount'
type KafkaSubscriberConfigBuilder_ManualCommitHandleMessageMaxRetryCount_Call struct {
	*mock.Call
}

// ManualCommitHandleMessageMaxRetryCount is a helper method to define mock.On call
//   - v
func (_e *KafkaSubscriberConfigBuilder_Expecter) ManualCommitHandleMessageMaxRetryCount(v interface{}) *KafkaSubscriberConfigBuilder_ManualCommitHandleMessageMaxRetryCount_Call {
	return &KafkaSubscriberConfigBuilder_ManualCommitHandleMessageMaxRetryCount_Call{Call: _e.mock.On("ManualCommitHandleMessageMaxRetryCount", v)}
}

func (_c *KafkaSubscriberConfigBuilder_ManualCommitHandleMessageMaxRetryCount_Call) Run(run func(v int)) *KafkaSubscriberConfigBuilder_ManualCommitHandleMessageMaxRetryCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_ManualCommitHandleMessageMaxRetryCount_Call) Return(subscriberConfigBuilder kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_ManualCommitHandleMessageMaxRetryCount_Call {
	_c.Call.Return(subscriberConfigBuilder)
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_ManualCommitHandleMessageMaxRetryCount_Call) RunAndReturn(run func(v int) kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_ManualCommitHandleMessageMaxRetryCount_Call {
	_c.Call.Return(run)
	return _c
}

// ManualCommitHandleMessageRetryBackoffStepMs provides a mock function for the type KafkaSubscriberConfigBuilder
func (_mock *KafkaSubscriberConfigBuilder) ManualCommitHandleMessageRetryBackoffStepMs(v int) kafka.SubscriberConfigBuilder {
	ret := _mock.Called(v)

	if len(ret) == 0 {
		panic("no return value specified for ManualCommitHandleMessageRetryBackoffStepMs")
	}

	var r0 kafka.SubscriberConfigBuilder
	if returnFunc, ok := ret.Get(0).(func(int) kafka.SubscriberConfigBuilder); ok {
		r0 = returnFunc(v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.SubscriberConfigBuilder)
		}
	}
	return r0
}

// KafkaSubscriberConfigBuilder_ManualCommitHandleMessageRetryBackoffStepMs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ManualCommitHandleMessageRetryBackoffStepMs'
type KafkaSubscriberConfigBuilder_ManualCommitHandleMessageRetryBackoffStepMs_Call struct {
	*mock.Call
}

// ManualCommitHandleMessageRetryBackoffStepMs is a helper method to define mock.On call
//   - v
func (_e *KafkaSubscriberConfigBuilder_Expecter) ManualCommitHandleMessageRetryBackoffStepMs(v interface{}) *KafkaSubscriberConfigBuilder_ManualCommitHandleMessageRetryBackoffStepMs_Call {
	return &KafkaSubscriberConfigBuilder_ManualCommitHandleMessageRetryBackoffStepMs_Call{Call: _e.mock.On("ManualCommitHandleMessageRetryBackoffStepMs", v)}
}

func (_c *KafkaSubscriberConfigBuilder_ManualCommitHandleMessageRetryBackoffStepMs_Call) Run(run func(v int)) *KafkaSubscriberConfigBuilder_ManualCommitHandleMessageRetryBackoffStepMs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_ManualCommitHandleMessageRetryBackoffStepMs_Call) Return(subscriberConfigBuilder kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_ManualCommitHandleMessageRetryBackoffStepMs_Call {
	_c.Call.Return(subscriberConfigBuilder)
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_ManualCommitHandleMessageRetryBackoffStepMs_Call) RunAndReturn(run func(v int) kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_ManualCommitHandleMessageRetryBackoffStepMs_Call {
	_c.Call.Return(run)
	return _c
}

// ManualCommitMessageMaxRetryCount provides a mock function for the type KafkaSubscriberConfigBuilder
func (_mock *KafkaSubscriberConfigBuilder) ManualCommitMessageMaxRetryCount(v int) kafka.SubscriberConfigBuilder {
	ret := _mock.Called(v)

	if len(ret) == 0 {
		panic("no return value specified for ManualCommitMessageMaxRetryCount")
	}

	var r0 kafka.SubscriberConfigBuilder
	if returnFunc, ok := ret.Get(0).(func(int) kafka.SubscriberConfigBuilder); ok {
		r0 = returnFunc(v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.SubscriberConfigBuilder)
		}
	}
	return r0
}

// KafkaSubscriberConfigBuilder_ManualCommitMessageMaxRetryCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ManualCommitMessageMaxRetryCount'
type KafkaSubscriberConfigBuilder_ManualCommitMessageMaxRetryCount_Call struct {
	*mock.Call
}

// ManualCommitMessageMaxRetryCount is a helper method to define mock.On call
//   - v
func (_e *KafkaSubscriberConfigBuilder_Expecter) ManualCommitMessageMaxRetryCount(v interface{}) *KafkaSubscriberConfigBuilder_ManualCommitMessageMaxRetryCount_Call {
	return &KafkaSubscriberConfigBuilder_ManualCommitMessageMaxRetryCount_Call{Call: _e.mock.On("ManualCommitMessageMaxRetryCount", v)}
}

func (_c *KafkaSubscriberConfigBuilder_ManualCommitMessageMaxRetryCount_Call) Run(run func(v int)) *KafkaSubscriberConfigBuilder_ManualCommitMessageMaxRetryCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_ManualCommitMessageMaxRetryCount_Call) Return(subscriberConfigBuilder kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_ManualCommitMessageMaxRetryCount_Call {
	_c.Call.Return(subscriberConfigBuilder)
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_ManualCommitMessageMaxRetryCount_Call) RunAndReturn(run func(v int) kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_ManualCommitMessageMaxRetryCount_Call {
	_c.Call.Return(run)
	return _c
}

// ManualCommitMessageRetryBackoffStepMs provides a mock function for the type KafkaSubscriberConfigBuilder
func (_mock *KafkaSubscriberConfigBuilder) ManualCommitMessageRetryBackoffStepMs(v int) kafka.SubscriberConfigBuilder {
	ret := _mock.Called(v)

	if len(ret) == 0 {
		panic("no return value specified for ManualCommitMessageRetryBackoffStepMs")
	}

	var r0 kafka.SubscriberConfigBuilder
	if returnFunc, ok := ret.Get(0).(func(int) kafka.SubscriberConfigBuilder); ok {
		r0 = returnFunc(v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.SubscriberConfigBuilder)
		}
	}
	return r0
}

// KafkaSubscriberConfigBuilder_ManualCommitMessageRetryBackoffStepMs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ManualCommitMessageRetryBackoffStepMs'
type KafkaSubscriberConfigBuilder_ManualCommitMessageRetryBackoffStepMs_Call struct {
	*mock.Call
}

// ManualCommitMessageRetryBackoffStepMs is a helper method to define mock.On call
//   - v
func (_e *KafkaSubscriberConfigBuilder_Expecter) ManualCommitMessageRetryBackoffStepMs(v interface{}) *KafkaSubscriberConfigBuilder_ManualCommitMessageRetryBackoffStepMs_Call {
	return &KafkaSubscriberConfigBuilder_ManualCommitMessageRetryBackoffStepMs_Call{Call: _e.mock.On("ManualCommitMessageRetryBackoffStepMs", v)}
}

func (_c *KafkaSubscriberConfigBuilder_ManualCommitMessageRetryBackoffStepMs_Call) Run(run func(v int)) *KafkaSubscriberConfigBuilder_ManualCommitMessageRetryBackoffStepMs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_ManualCommitMessageRetryBackoffStepMs_Call) Return(subscriberConfigBuilder kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_ManualCommitMessageRetryBackoffStepMs_Call {
	_c.Call.Return(subscriberConfigBuilder)
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_ManualCommitMessageRetryBackoffStepMs_Call) RunAndReturn(run func(v int) kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_ManualCommitMessageRetryBackoffStepMs_Call {
	_c.Call.Return(run)
	return _c
}

// MaxWait provides a mock function for the type KafkaSubscriberConfigBuilder
func (_mock *KafkaSubscriberConfigBuilder) MaxWait(to time.Duration) kafka.SubscriberConfigBuilder {
	ret := _mock.Called(to)

	if len(ret) == 0 {
		panic("no return value specified for MaxWait")
	}

	var r0 kafka.SubscriberConfigBuilder
	if returnFunc, ok := ret.Get(0).(func(time.Duration) kafka.SubscriberConfigBuilder); ok {
		r0 = returnFunc(to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.SubscriberConfigBuilder)
		}
	}
	return r0
}

// KafkaSubscriberConfigBuilder_MaxWait_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MaxWait'
type KafkaSubscriberConfigBuilder_MaxWait_Call struct {
	*mock.Call
}

// MaxWait is a helper method to define mock.On call
//   - to
func (_e *KafkaSubscriberConfigBuilder_Expecter) MaxWait(to interface{}) *KafkaSubscriberConfigBuilder_MaxWait_Call {
	return &KafkaSubscriberConfigBuilder_MaxWait_Call{Call: _e.mock.On("MaxWait", to)}
}

func (_c *KafkaSubscriberConfigBuilder_MaxWait_Call) Run(run func(to time.Duration)) *KafkaSubscriberConfigBuilder_MaxWait_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Duration))
	})
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_MaxWait_Call) Return(subscriberConfigBuilder kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_MaxWait_Call {
	_c.Call.Return(subscriberConfigBuilder)
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_MaxWait_Call) RunAndReturn(run func(to time.Duration) kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_MaxWait_Call {
	_c.Call.Return(run)
	return _c
}

// StartOffset provides a mock function for the type KafkaSubscriberConfigBuilder
func (_mock *KafkaSubscriberConfigBuilder) StartOffset(v int64) kafka.SubscriberConfigBuilder {
	ret := _mock.Called(v)

	if len(ret) == 0 {
		panic("no return value specified for StartOffset")
	}

	var r0 kafka.SubscriberConfigBuilder
	if returnFunc, ok := ret.Get(0).(func(int64) kafka.SubscriberConfigBuilder); ok {
		r0 = returnFunc(v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.SubscriberConfigBuilder)
		}
	}
	return r0
}

// KafkaSubscriberConfigBuilder_StartOffset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartOffset'
type KafkaSubscriberConfigBuilder_StartOffset_Call struct {
	*mock.Call
}

// StartOffset is a helper method to define mock.On call
//   - v
func (_e *KafkaSubscriberConfigBuilder_Expecter) StartOffset(v interface{}) *KafkaSubscriberConfigBuilder_StartOffset_Call {
	return &KafkaSubscriberConfigBuilder_StartOffset_Call{Call: _e.mock.On("StartOffset", v)}
}

func (_c *KafkaSubscriberConfigBuilder_StartOffset_Call) Run(run func(v int64)) *KafkaSubscriberConfigBuilder_StartOffset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int64))
	})
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_StartOffset_Call) Return(subscriberConfigBuilder kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_StartOffset_Call {
	_c.Call.Return(subscriberConfigBuilder)
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_StartOffset_Call) RunAndReturn(run func(v int64) kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_StartOffset_Call {
	_c.Call.Return(run)
	return _c
}

// Validate provides a mock function for the type KafkaSubscriberConfigBuilder
func (_mock *KafkaSubscriberConfigBuilder) Validate(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Validate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// KafkaSubscriberConfigBuilder_Validate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Validate'
type KafkaSubscriberConfigBuilder_Validate_Call struct {
	*mock.Call
}

// Validate is a helper method to define mock.On call
//   - ctx
func (_e *KafkaSubscriberConfigBuilder_Expecter) Validate(ctx interface{}) *KafkaSubscriberConfigBuilder_Validate_Call {
	return &KafkaSubscriberConfigBuilder_Validate_Call{Call: _e.mock.On("Validate", ctx)}
}

func (_c *KafkaSubscriberConfigBuilder_Validate_Call) Run(run func(ctx context.Context)) *KafkaSubscriberConfigBuilder_Validate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_Validate_Call) Return(err error) *KafkaSubscriberConfigBuilder_Validate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_Validate_Call) RunAndReturn(run func(ctx context.Context) error) *KafkaSubscriberConfigBuilder_Validate_Call {
	_c.Call.Return(run)
	return _c
}

// Workers provides a mock function for the type KafkaSubscriberConfigBuilder
func (_mock *KafkaSubscriberConfigBuilder) Workers(num int) kafka.SubscriberConfigBuilder {
	ret := _mock.Called(num)

	if len(ret) == 0 {
		panic("no return value specified for Workers")
	}

	var r0 kafka.SubscriberConfigBuilder
	if returnFunc, ok := ret.Get(0).(func(int) kafka.SubscriberConfigBuilder); ok {
		r0 = returnFunc(num)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.SubscriberConfigBuilder)
		}
	}
	return r0
}

// KafkaSubscriberConfigBuilder_Workers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Workers'
type KafkaSubscriberConfigBuilder_Workers_Call struct {
	*mock.Call
}

// Workers is a helper method to define mock.On call
//   - num
func (_e *KafkaSubscriberConfigBuilder_Expecter) Workers(num interface{}) *KafkaSubscriberConfigBuilder_Workers_Call {
	return &KafkaSubscriberConfigBuilder_Workers_Call{Call: _e.mock.On("Workers", num)}
}

func (_c *KafkaSubscriberConfigBuilder_Workers_Call) Run(run func(num int)) *KafkaSubscriberConfigBuilder_Workers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_Workers_Call) Return(subscriberConfigBuilder kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_Workers_Call {
	_c.Call.Return(subscriberConfigBuilder)
	return _c
}

func (_c *KafkaSubscriberConfigBuilder_Workers_Call) RunAndReturn(run func(num int) kafka.SubscriberConfigBuilder) *KafkaSubscriberConfigBuilder_Workers_Call {
	_c.Call.Return(run)
	return _c
}

// NewKafkaTopicBuilder creates a new instance of KafkaTopicBuilder. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKafkaTopicBuilder(t interface {
	mock.TestingT
	Cleanup(func())
}) *KafkaTopicBuilder {
	mock := &KafkaTopicBuilder{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// KafkaTopicBuilder is an autogenerated mock type for the TopicBuilder type
type KafkaTopicBuilder struct {
	mock.Mock
}

type KafkaTopicBuilder_Expecter struct {
	mock *mock.Mock
}

func (_m *KafkaTopicBuilder) EXPECT() *KafkaTopicBuilder_Expecter {
	return &KafkaTopicBuilder_Expecter{mock: &_m.Mock}
}

// Build provides a mock function for the type KafkaTopicBuilder
func (_mock *KafkaTopicBuilder) Build() *kafka.TopicConfig {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Build")
	}

	var r0 *kafka.TopicConfig
	if returnFunc, ok := ret.Get(0).(func() *kafka.TopicConfig); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kafka.TopicConfig)
		}
	}
	return r0
}

// KafkaTopicBuilder_Build_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Build'
type KafkaTopicBuilder_Build_Call struct {
	*mock.Call
}

// Build is a helper method to define mock.On call
func (_e *KafkaTopicBuilder_Expecter) Build() *KafkaTopicBuilder_Build_Call {
	return &KafkaTopicBuilder_Build_Call{Call: _e.mock.On("Build")}
}

func (_c *KafkaTopicBuilder_Build_Call) Run(run func()) *KafkaTopicBuilder_Build_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KafkaTopicBuilder_Build_Call) Return(topicConfig *kafka.TopicConfig) *KafkaTopicBuilder_Build_Call {
	_c.Call.Return(topicConfig)
	return _c
}

func (_c *KafkaTopicBuilder_Build_Call) RunAndReturn(run func() *kafka.TopicConfig) *KafkaTopicBuilder_Build_Call {
	_c.Call.Return(run)
	return _c
}

// WithParams provides a mock function for the type KafkaTopicBuilder
func (_mock *KafkaTopicBuilder) WithParams(params ...kafka.TopicParam) kafka.TopicBuilder {
	var tmpRet mock.Arguments
	if len(params) > 0 {
		tmpRet = _mock.Called(params)
	} else {
		tmpRet = _mock.Called()
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for WithParams")
	}

	var r0 kafka.TopicBuilder
	if returnFunc, ok := ret.Get(0).(func(...kafka.TopicParam) kafka.TopicBuilder); ok {
		r0 = returnFunc(params...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.TopicBuilder)
		}
	}
	return r0
}

// KafkaTopicBuilder_WithParams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithParams'
type KafkaTopicBuilder_WithParams_Call struct {
	*mock.Call
}

// WithParams is a helper method to define mock.On call
//   - params
func (_e *KafkaTopicBuilder_Expecter) WithParams(params ...interface{}) *KafkaTopicBuilder_WithParams_Call {
	return &KafkaTopicBuilder_WithParams_Call{Call: _e.mock.On("WithParams",
		append([]interface{}{}, params...)...)}
}

func (_c *KafkaTopicBuilder_WithParams_Call) Run(run func(params ...kafka.TopicParam)) *KafkaTopicBuilder_WithParams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[0].([]kafka.TopicParam)
		run(variadicArgs...)
	})
	return _c
}

func (_c *KafkaTopicBuilder_WithParams_Call) Return(topicBuilder kafka.TopicBuilder) *KafkaTopicBuilder_WithParams_Call {
	_c.Call.Return(topicBuilder)
	return _c
}

func (_c *KafkaTopicBuilder_WithParams_Call) RunAndReturn(run func(params ...kafka.TopicParam) kafka.TopicBuilder) *KafkaTopicBuilder_WithParams_Call {
	_c.Call.Return(run)
	return _c
}

// WithPartitionNum provides a mock function for the type KafkaTopicBuilder
func (_mock *KafkaTopicBuilder) WithPartitionNum(num int) kafka.TopicBuilder {
	ret := _mock.Called(num)

	if len(ret) == 0 {
		panic("no return value specified for WithPartitionNum")
	}

	var r0 kafka.TopicBuilder
	if returnFunc, ok := ret.Get(0).(func(int) kafka.TopicBuilder); ok {
		r0 = returnFunc(num)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kafka.TopicBuilder)
		}
	}
	return r0
}

// KafkaTopicBuilder_WithPartitionNum_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithPartitionNum'
type KafkaTopicBuilder_WithPartitionNum_Call struct {
	*mock.Call
}

// WithPartitionNum is a helper method to define mock.On call
//   - num
func (_e *KafkaTopicBuilder_Expecter) WithPartitionNum(num interface{}) *KafkaTopicBuilder_WithPartitionNum_Call {
	return &KafkaTopicBuilder_WithPartitionNum_Call{Call: _e.mock.On("WithPartitionNum", num)}
}

func (_c *KafkaTopicBuilder_WithPartitionNum_Call) Run(run func(num int)) *KafkaTopicBuilder_WithPartitionNum_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *KafkaTopicBuilder_WithPartitionNum_Call) Return(topicBuilder kafka.TopicBuilder) *KafkaTopicBuilder_WithPartitionNum_Call {
	_c.Call.Return(topicBuilder)
	return _c
}

func (_c *KafkaTopicBuilder_WithPartitionNum_Call) RunAndReturn(run func(num int) kafka.TopicBuilder) *KafkaTopicBuilder_WithPartitionNum_Call {
	_c.Call.Return(run)
	return _c
}
