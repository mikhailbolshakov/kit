// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"net/http"

	"github.com/gorilla/mux"
	"github.com/gorilla/websocket"
	http0 "github.com/mikhailbolshakov/kit/http"
	mock "github.com/stretchr/testify/mock"
)

// NewHttpController creates a new instance of HttpController. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewHttpController(t interface {
	mock.TestingT
	Cleanup(func())
}) *HttpController {
	mock := &HttpController{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// HttpController is an autogenerated mock type for the Controller type
type HttpController struct {
	mock.Mock
}

type HttpController_Expecter struct {
	mock *mock.Mock
}

func (_m *HttpController) EXPECT() *HttpController_Expecter {
	return &HttpController_Expecter{mock: &_m.Mock}
}

// HasRoles provides a mock function for the type HttpController
func (_mock *HttpController) HasRoles(roles ...string) func(ctx context.Context, r *http.Request) (bool, error) {
	var tmpRet mock.Arguments
	if len(roles) > 0 {
		tmpRet = _mock.Called(roles)
	} else {
		tmpRet = _mock.Called()
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for HasRoles")
	}

	var r0 func(ctx context.Context, r *http.Request) (bool, error)
	if returnFunc, ok := ret.Get(0).(func(...string) func(ctx context.Context, r *http.Request) (bool, error)); ok {
		r0 = returnFunc(roles...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(func(ctx context.Context, r *http.Request) (bool, error))
		}
	}
	return r0
}

// HttpController_HasRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasRoles'
type HttpController_HasRoles_Call struct {
	*mock.Call
}

// HasRoles is a helper method to define mock.On call
//   - roles
func (_e *HttpController_Expecter) HasRoles(roles ...interface{}) *HttpController_HasRoles_Call {
	return &HttpController_HasRoles_Call{Call: _e.mock.On("HasRoles",
		append([]interface{}{}, roles...)...)}
}

func (_c *HttpController_HasRoles_Call) Run(run func(roles ...string)) *HttpController_HasRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[0].([]string)
		run(variadicArgs...)
	})
	return _c
}

func (_c *HttpController_HasRoles_Call) Return(fn func(ctx context.Context, r *http.Request) (bool, error)) *HttpController_HasRoles_Call {
	_c.Call.Return(fn)
	return _c
}

func (_c *HttpController_HasRoles_Call) RunAndReturn(run func(roles ...string) func(ctx context.Context, r *http.Request) (bool, error)) *HttpController_HasRoles_Call {
	_c.Call.Return(run)
	return _c
}

// MyUser provides a mock function for the type HttpController
func (_mock *HttpController) MyUser(ctx context.Context, r *http.Request) (bool, error) {
	ret := _mock.Called(ctx, r)

	if len(ret) == 0 {
		panic("no return value specified for MyUser")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *http.Request) (bool, error)); ok {
		return returnFunc(ctx, r)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *http.Request) bool); ok {
		r0 = returnFunc(ctx, r)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *http.Request) error); ok {
		r1 = returnFunc(ctx, r)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// HttpController_MyUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MyUser'
type HttpController_MyUser_Call struct {
	*mock.Call
}

// MyUser is a helper method to define mock.On call
//   - ctx
//   - r
func (_e *HttpController_Expecter) MyUser(ctx interface{}, r interface{}) *HttpController_MyUser_Call {
	return &HttpController_MyUser_Call{Call: _e.mock.On("MyUser", ctx, r)}
}

func (_c *HttpController_MyUser_Call) Run(run func(ctx context.Context, r *http.Request)) *HttpController_MyUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*http.Request))
	})
	return _c
}

func (_c *HttpController_MyUser_Call) Return(b bool, err error) *HttpController_MyUser_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *HttpController_MyUser_Call) RunAndReturn(run func(ctx context.Context, r *http.Request) (bool, error)) *HttpController_MyUser_Call {
	_c.Call.Return(run)
	return _c
}

// NewHttpResourcePolicyManager creates a new instance of HttpResourcePolicyManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewHttpResourcePolicyManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *HttpResourcePolicyManager {
	mock := &HttpResourcePolicyManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// HttpResourcePolicyManager is an autogenerated mock type for the ResourcePolicyManager type
type HttpResourcePolicyManager struct {
	mock.Mock
}

type HttpResourcePolicyManager_Expecter struct {
	mock *mock.Mock
}

func (_m *HttpResourcePolicyManager) EXPECT() *HttpResourcePolicyManager_Expecter {
	return &HttpResourcePolicyManager_Expecter{mock: &_m.Mock}
}

// GetRequestedResources provides a mock function for the type HttpResourcePolicyManager
func (_mock *HttpResourcePolicyManager) GetRequestedResources(ctx context.Context, routeId string, r *http.Request) ([]*http0.AuthorizationResource, error) {
	ret := _mock.Called(ctx, routeId, r)

	if len(ret) == 0 {
		panic("no return value specified for GetRequestedResources")
	}

	var r0 []*http0.AuthorizationResource
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *http.Request) ([]*http0.AuthorizationResource, error)); ok {
		return returnFunc(ctx, routeId, r)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *http.Request) []*http0.AuthorizationResource); ok {
		r0 = returnFunc(ctx, routeId, r)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*http0.AuthorizationResource)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, *http.Request) error); ok {
		r1 = returnFunc(ctx, routeId, r)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// HttpResourcePolicyManager_GetRequestedResources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRequestedResources'
type HttpResourcePolicyManager_GetRequestedResources_Call struct {
	*mock.Call
}

// GetRequestedResources is a helper method to define mock.On call
//   - ctx
//   - routeId
//   - r
func (_e *HttpResourcePolicyManager_Expecter) GetRequestedResources(ctx interface{}, routeId interface{}, r interface{}) *HttpResourcePolicyManager_GetRequestedResources_Call {
	return &HttpResourcePolicyManager_GetRequestedResources_Call{Call: _e.mock.On("GetRequestedResources", ctx, routeId, r)}
}

func (_c *HttpResourcePolicyManager_GetRequestedResources_Call) Run(run func(ctx context.Context, routeId string, r *http.Request)) *HttpResourcePolicyManager_GetRequestedResources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*http.Request))
	})
	return _c
}

func (_c *HttpResourcePolicyManager_GetRequestedResources_Call) Return(authorizationResources []*http0.AuthorizationResource, err error) *HttpResourcePolicyManager_GetRequestedResources_Call {
	_c.Call.Return(authorizationResources, err)
	return _c
}

func (_c *HttpResourcePolicyManager_GetRequestedResources_Call) RunAndReturn(run func(ctx context.Context, routeId string, r *http.Request) ([]*http0.AuthorizationResource, error)) *HttpResourcePolicyManager_GetRequestedResources_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterResourceMapping provides a mock function for the type HttpResourcePolicyManager
func (_mock *HttpResourcePolicyManager) RegisterResourceMapping(routeId string, policies ...http0.ResourcePolicy) {
	if len(policies) > 0 {
		_mock.Called(routeId, policies)
	} else {
		_mock.Called(routeId)
	}

	return
}

// HttpResourcePolicyManager_RegisterResourceMapping_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterResourceMapping'
type HttpResourcePolicyManager_RegisterResourceMapping_Call struct {
	*mock.Call
}

// RegisterResourceMapping is a helper method to define mock.On call
//   - routeId
//   - policies
func (_e *HttpResourcePolicyManager_Expecter) RegisterResourceMapping(routeId interface{}, policies ...interface{}) *HttpResourcePolicyManager_RegisterResourceMapping_Call {
	return &HttpResourcePolicyManager_RegisterResourceMapping_Call{Call: _e.mock.On("RegisterResourceMapping",
		append([]interface{}{routeId}, policies...)...)}
}

func (_c *HttpResourcePolicyManager_RegisterResourceMapping_Call) Run(run func(routeId string, policies ...http0.ResourcePolicy)) *HttpResourcePolicyManager_RegisterResourceMapping_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[1].([]http0.ResourcePolicy)
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *HttpResourcePolicyManager_RegisterResourceMapping_Call) Return() *HttpResourcePolicyManager_RegisterResourceMapping_Call {
	_c.Call.Return()
	return _c
}

func (_c *HttpResourcePolicyManager_RegisterResourceMapping_Call) RunAndReturn(run func(routeId string, policies ...http0.ResourcePolicy)) *HttpResourcePolicyManager_RegisterResourceMapping_Call {
	_c.Run(run)
	return _c
}

// NewHttpResourcePolicy creates a new instance of HttpResourcePolicy. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewHttpResourcePolicy(t interface {
	mock.TestingT
	Cleanup(func())
}) *HttpResourcePolicy {
	mock := &HttpResourcePolicy{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// HttpResourcePolicy is an autogenerated mock type for the ResourcePolicy type
type HttpResourcePolicy struct {
	mock.Mock
}

type HttpResourcePolicy_Expecter struct {
	mock *mock.Mock
}

func (_m *HttpResourcePolicy) EXPECT() *HttpResourcePolicy_Expecter {
	return &HttpResourcePolicy_Expecter{mock: &_m.Mock}
}

// Resolve provides a mock function for the type HttpResourcePolicy
func (_mock *HttpResourcePolicy) Resolve(ctx context.Context, r *http.Request) (*http0.AuthorizationResource, error) {
	ret := _mock.Called(ctx, r)

	if len(ret) == 0 {
		panic("no return value specified for Resolve")
	}

	var r0 *http0.AuthorizationResource
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *http.Request) (*http0.AuthorizationResource, error)); ok {
		return returnFunc(ctx, r)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *http.Request) *http0.AuthorizationResource); ok {
		r0 = returnFunc(ctx, r)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http0.AuthorizationResource)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *http.Request) error); ok {
		r1 = returnFunc(ctx, r)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// HttpResourcePolicy_Resolve_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Resolve'
type HttpResourcePolicy_Resolve_Call struct {
	*mock.Call
}

// Resolve is a helper method to define mock.On call
//   - ctx
//   - r
func (_e *HttpResourcePolicy_Expecter) Resolve(ctx interface{}, r interface{}) *HttpResourcePolicy_Resolve_Call {
	return &HttpResourcePolicy_Resolve_Call{Call: _e.mock.On("Resolve", ctx, r)}
}

func (_c *HttpResourcePolicy_Resolve_Call) Run(run func(ctx context.Context, r *http.Request)) *HttpResourcePolicy_Resolve_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*http.Request))
	})
	return _c
}

func (_c *HttpResourcePolicy_Resolve_Call) Return(authorizationResource *http0.AuthorizationResource, err error) *HttpResourcePolicy_Resolve_Call {
	_c.Call.Return(authorizationResource, err)
	return _c
}

func (_c *HttpResourcePolicy_Resolve_Call) RunAndReturn(run func(ctx context.Context, r *http.Request) (*http0.AuthorizationResource, error)) *HttpResourcePolicy_Resolve_Call {
	_c.Call.Return(run)
	return _c
}

// NewHttpHttpClient creates a new instance of HttpHttpClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewHttpHttpClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *HttpHttpClient {
	mock := &HttpHttpClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// HttpHttpClient is an autogenerated mock type for the HttpClient type
type HttpHttpClient struct {
	mock.Mock
}

type HttpHttpClient_Expecter struct {
	mock *mock.Mock
}

func (_m *HttpHttpClient) EXPECT() *HttpHttpClient_Expecter {
	return &HttpHttpClient_Expecter{mock: &_m.Mock}
}

// Do provides a mock function for the type HttpHttpClient
func (_mock *HttpHttpClient) Do(req *http.Request) (*http.Response, error) {
	ret := _mock.Called(req)

	if len(ret) == 0 {
		panic("no return value specified for Do")
	}

	var r0 *http.Response
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*http.Request) (*http.Response, error)); ok {
		return returnFunc(req)
	}
	if returnFunc, ok := ret.Get(0).(func(*http.Request) *http.Response); ok {
		r0 = returnFunc(req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*http.Request) error); ok {
		r1 = returnFunc(req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// HttpHttpClient_Do_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Do'
type HttpHttpClient_Do_Call struct {
	*mock.Call
}

// Do is a helper method to define mock.On call
//   - req
func (_e *HttpHttpClient_Expecter) Do(req interface{}) *HttpHttpClient_Do_Call {
	return &HttpHttpClient_Do_Call{Call: _e.mock.On("Do", req)}
}

func (_c *HttpHttpClient_Do_Call) Run(run func(req *http.Request)) *HttpHttpClient_Do_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*http.Request))
	})
	return _c
}

func (_c *HttpHttpClient_Do_Call) Return(response *http.Response, err error) *HttpHttpClient_Do_Call {
	_c.Call.Return(response, err)
	return _c
}

func (_c *HttpHttpClient_Do_Call) RunAndReturn(run func(req *http.Request) (*http.Response, error)) *HttpHttpClient_Do_Call {
	_c.Call.Return(run)
	return _c
}

// NewHttpRouteSetter creates a new instance of HttpRouteSetter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewHttpRouteSetter(t interface {
	mock.TestingT
	Cleanup(func())
}) *HttpRouteSetter {
	mock := &HttpRouteSetter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// HttpRouteSetter is an autogenerated mock type for the RouteSetter type
type HttpRouteSetter struct {
	mock.Mock
}

type HttpRouteSetter_Expecter struct {
	mock *mock.Mock
}

func (_m *HttpRouteSetter) EXPECT() *HttpRouteSetter_Expecter {
	return &HttpRouteSetter_Expecter{mock: &_m.Mock}
}

// Set provides a mock function for the type HttpRouteSetter
func (_mock *HttpRouteSetter) Set() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Set")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// HttpRouteSetter_Set_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Set'
type HttpRouteSetter_Set_Call struct {
	*mock.Call
}

// Set is a helper method to define mock.On call
func (_e *HttpRouteSetter_Expecter) Set() *HttpRouteSetter_Set_Call {
	return &HttpRouteSetter_Set_Call{Call: _e.mock.On("Set")}
}

func (_c *HttpRouteSetter_Set_Call) Run(run func()) *HttpRouteSetter_Set_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *HttpRouteSetter_Set_Call) Return(err error) *HttpRouteSetter_Set_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *HttpRouteSetter_Set_Call) RunAndReturn(run func() error) *HttpRouteSetter_Set_Call {
	_c.Call.Return(run)
	return _c
}

// NewHttpWsUpgrader creates a new instance of HttpWsUpgrader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewHttpWsUpgrader(t interface {
	mock.TestingT
	Cleanup(func())
}) *HttpWsUpgrader {
	mock := &HttpWsUpgrader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// HttpWsUpgrader is an autogenerated mock type for the WsUpgrader type
type HttpWsUpgrader struct {
	mock.Mock
}

type HttpWsUpgrader_Expecter struct {
	mock *mock.Mock
}

func (_m *HttpWsUpgrader) EXPECT() *HttpWsUpgrader_Expecter {
	return &HttpWsUpgrader_Expecter{mock: &_m.Mock}
}

// Set provides a mock function for the type HttpWsUpgrader
func (_mock *HttpWsUpgrader) Set(router *mux.Router, upgrader *websocket.Upgrader) {
	_mock.Called(router, upgrader)
	return
}

// HttpWsUpgrader_Set_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Set'
type HttpWsUpgrader_Set_Call struct {
	*mock.Call
}

// Set is a helper method to define mock.On call
//   - router
//   - upgrader
func (_e *HttpWsUpgrader_Expecter) Set(router interface{}, upgrader interface{}) *HttpWsUpgrader_Set_Call {
	return &HttpWsUpgrader_Set_Call{Call: _e.mock.On("Set", router, upgrader)}
}

func (_c *HttpWsUpgrader_Set_Call) Run(run func(router *mux.Router, upgrader *websocket.Upgrader)) *HttpWsUpgrader_Set_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*mux.Router), args[1].(*websocket.Upgrader))
	})
	return _c
}

func (_c *HttpWsUpgrader_Set_Call) Return() *HttpWsUpgrader_Set_Call {
	_c.Call.Return()
	return _c
}

func (_c *HttpWsUpgrader_Set_Call) RunAndReturn(run func(router *mux.Router, upgrader *websocket.Upgrader)) *HttpWsUpgrader_Set_Call {
	_c.Run(run)
	return _c
}
